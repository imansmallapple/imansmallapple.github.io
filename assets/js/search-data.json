{"0": {
    "doc": "Application Package Structure in Stage Model",
    "title": "Application Model Overview",
    "content": "The system has provided two application models: . | Feature Ability (FA) model: This model is supported by API versions 7 and 8, and no longer recommended. | Stage model: This model is supported since API version 9. It is the mainstream model with a long evolution plan. In this model, classes such as AbilityStage and WindowStage are provided as the stage of application components and windows. That’s why it is named stage model. | . ",
    "url": "/application-development/basic-concepts/app-pack-structure.html#application-model-overview",
    
    "relUrl": "/application-development/basic-concepts/app-pack-structure.html#application-model-overview"
  },"1": {
    "doc": "Application Package Structure in Stage Model",
    "title": "Package Structure in the Development Phase",
    "content": "To have a clearer idea on the application package structure, it would be helpful if you have a project directory at hand. As such, first create a project in DevEco Studio and add modules of different types to the project. Figure 1 Project structure (for reference only) . The table below lists the main file types in the project structure. NOTE . | The AppScope directory is automatically generated by DevEco Studio and its name cannot be changed. | The module directory name can be automatically generated by DevEco Studio (for example, entry and library) or customized. For ease of description, Module_name is used below to represent the module directory name. | . | File Type | Description | . | Configuration files | A collection of application-level and module-level configurations. - AppScope &gt; app.json5: application-wide configuration, such as the bundle name, version number, application icon, application name, and dependent SDK version number. - Module_name &gt; src &gt; main &gt; module.json5: basic information, supported device types, component information, and required permissions of the module. | . | ArkTS source code files | Module_name &gt; src &gt; main &gt; ets: ArkTS source code files of the module. | . | Resource files | A collection of application-level and module-level resource files, including images, multimedia, strings, and layout files. For details, see Resource Categories and Access. - AppScope &gt; resources: resource files required for the application. - Module_name &gt; src &gt; main &gt; resources: resource files required for the module. | . | Other configuration files | A collection of files used for compilation and building, including build configuration files, build scripts, obfuscation rule files, and files declaring dependencies. - build-profile.json5: project-level or module-level build configurations, including application signatures and product configurations. - hvigorfile.ts: application-level or module-level build script. You can specify the compilation and build tool version and configuration parameters for controlling build behavior. - obfuscation-rules.txt: obfuscation rule file. When obfuscation is enabled, DevEco Studio compiles, obfuscates, and compresses code during builds in Release mode. - oh-package.json5: information about dependencies, including dependent third-party libraries and shared packages. | . ",
    "url": "/application-development/basic-concepts/app-pack-structure.html#package-structure-in-the-development-phase",
    
    "relUrl": "/application-development/basic-concepts/app-pack-structure.html#package-structure-in-the-development-phase"
  },"2": {
    "doc": "Application Package Structure in Stage Model",
    "title": "Selecting a File Type",
    "content": "There are two types of modules by usage scenario: . | Modules of the ability type: used to implement application functionality. Each module of the ability type is built into a Harmony Ability Package (HAP), in .hap format. As a basic unit for application installation, a HAP can be installed and run separately. An application contains one or more HAPs. Depending on the module from each it is built, a HAP is of the entry or feature type. | Entry HAP: built from an entry module, which serves as the application’s main module and implements the application’s entry screen, entry icon, or headline feature. Each application package distributed to devices of the same type may contain either zero or one entry HAP. | Feature HAP: built from a dynamic feature module. An application can contain zero, one, or more feature HAPs. | . | Modules of the library type: used to implement code and resource sharing. This type of module can be referenced by other modules multiple times and, when used smartly, can reduce development and maintenance costs. Modules of the library type are classified as static or shared. Each is built into a shared package. | Static: static shared library. This type of library is built into a Harmony Archive (HAR), in .har format. | Shared: dynamic shared library. This type of library is built into a Harmony Shared Package (HSP), in .hsp format. | . NOTE . Actually, a build of the shared library generates a HAR as well as an HSP. The HAR contains the interfaces exported from the HSP and is used by other modules in the application to reference the features of the HSP. For convenience purposes, it is usually considered that a shared library is built into an HSP. The table below lists the differences between the HAR and HSP. | . | Shared Package Type | Build and Running | Release and Reference | . | HAR | The code and resources in the HAR are built with the invoking module, and if there are multiple invoking modules, the build product contains multiple copies of the same code and resources.Note: When building a HAR, you are advised to enable the obfuscation capability to protect code assets. | The HAR can be referenced inside the application and, by being released independently, can be referenced across applications. | . | HSP | The code and resources in the HSP are built independently, and the build product contains only one copy of the code and resources. | Generally, the HSP is packaged with the application. Intra-application HSP and integrated HSP are supported. The intra-app HSP can only be referenced in an application; the integrated HSP can be published to the ohpm private repository and referenced in cross-applications. | . Figure 2 HAR and HSP in the App Pack . ",
    "url": "/application-development/basic-concepts/app-pack-structure.html#selecting-a-file-type",
    
    "relUrl": "/application-development/basic-concepts/app-pack-structure.html#selecting-a-file-type"
  },"3": {
    "doc": "Application Package Structure in Stage Model",
    "title": "Application Package Structure in Stage Model",
    "content": "Text referenced from here and here . This topic explores the structure of an application package in the phase of application development. Content table: . | Application Model Overview | Package Structure in the Development Phase | Selecting a File Type | . ",
    "url": "/application-development/basic-concepts/app-pack-structure.html",
    
    "relUrl": "/application-development/basic-concepts/app-pack-structure.html"
  },"4": {
    "doc": "AppStorage",
    "title": "AppStorage",
    "content": "AppStorage provides central storage for application UI state attributes. It is bound to the application process and is created by the UI framework at application startup. Unlike LocalStorage, which is usually used for page-level state sharing, AppStorage enables application-wide UI state sharing. AppStorage is equivalent to the hub of the entire application. This topic describes the AppStorage use scenarios and related decorators: @StorageProp and @StorageLink. ",
    "url": "/application-development/state-management-decorators/appstorage.html",
    
    "relUrl": "/application-development/state-management-decorators/appstorage.html"
  },"5": {
    "doc": "AppStorage",
    "title": "Overview",
    "content": "AppStorage is a built-in global storage that is created automatically when your app starts. It’s designed to store shared data that your UI components can access and update at any time. | Think of it as a central place to keep important app-level values, like user settings, theme colors, or login status. | The data in AppStorage stays there as long as the app is running. | Each piece of data is stored with a unique string key, similar to a dictionary or map. | . UI components can automatically stay in sync with values in AppStorage. So when the value changes, the UI updates too. You can also use AppStorage to share state between multiple pages (UIAbility instances) in your app, as long as they run on the main thread. If you want some values to be saved even after the app is closed, you can connect AppStorage to other storage sources—like databases or cloud services—using decorators like @StorageProp and @StorageLink. ",
    "url": "/application-development/state-management-decorators/appstorage.html#overview",
    
    "relUrl": "/application-development/state-management-decorators/appstorage.html#overview"
  },"6": {
    "doc": "AppStorage",
    "title": "@StorageProp",
    "content": "As mentioned above, if you want to establish a binding between AppStorage and a custom component, you’ll need the @StorageProp or @StorageLink decorator. Use @StorageProp(key) or @StorageLink(key) to decorate variables in the component, where key identifies an attribute in AppStorage. When a custom component is initialized, the attribute value corresponding to the key in AppStorage is used to initialize the @StorageProp(key) or @StorageLink(key) decorated variable. Whether the attribute with the given key exists in AppStorage depends on the application logic. This means that it may be missing from AppStorage. In light of this, local initialization is mandatory for the @StorageProp(key) or @StorageLink(key) decorated variable. By decorating a variable with @StorageProp(key), a one-way data synchronization is established from the attribute with the given key in AppStorage to the variable. A local change can be made, but it will not be synchronized to AppStorage. An update to the attribute with the given key in AppStorage will overwrite local changes. ",
    "url": "/application-development/state-management-decorators/appstorage.html#storageprop",
    
    "relUrl": "/application-development/state-management-decorators/appstorage.html#storageprop"
  },"7": {
    "doc": "AppStorage",
    "title": "@StorageLink",
    "content": "@StorageLink(key) creates a two-way data synchronization between the variable it decorates and the attribute with the given key in AppStorage. | Local changes are synchronized to AppStorage. | Any change in AppStorage is synchronized to the attribute with the given key in all scenarios, including one-way bound variables (@StorageProp decorated variables and one-way bound variables created through @Prop), two-way bound variables (@StorageLink decorated variables and two-way bound variables created through @Link), and other instances (such as PersistentStorage). | . ",
    "url": "/application-development/state-management-decorators/appstorage.html#storagelink",
    
    "relUrl": "/application-development/state-management-decorators/appstorage.html#storagelink"
  },"8": {
    "doc": "AppStorage",
    "title": "Use Scenarios",
    "content": "Example of Using AppStorage and LocalStorage in Application Logic . Since AppStorage is a singleton, its APIs are all static. How these APIs work resembles the non-static APIs of LocalStorage. AppStorage.setOrCreate('PropA', 47); let storage: LocalStorage = new LocalStorage(); storage.setOrCreate('PropA',17); let propA: number | undefined = AppStorage.get('PropA') // propA in AppStorage == 47, propA in LocalStorage == 17 let link1: SubscribedAbstractProperty&lt;number&gt; = AppStorage.link('PropA'); // link1.get() == 47 let link2: SubscribedAbstractProperty&lt;number&gt; = AppStorage.link('PropA'); // link2.get() == 47 let prop: SubscribedAbstractProperty&lt;number&gt; = AppStorage.prop('PropA'); // prop.get() == 47 link1.set(48); // two-way sync: link1.get() == link2.get() == prop.get() == 48 prop.set(1); // one-way sync: prop.get() == 1; but link1.get() == link2.get() == 48 link1.set(49); // two-way sync: link1.get() == link2.get() == prop.get() == 49 storage.get&lt;number&gt;('PropA') // == 17 storage.set('PropA', 101); storage.get&lt;number&gt;('PropA') // == 101 AppStorage.get&lt;number&gt;('PropA') // == 49 link1.get() // == 49 link2.get() // == 49 prop.get() // == 49 . Example of Using AppStorage and LocalStorage Inside the UI . @StorageLink works together with AppStorage in the same way as @LocalStorageLink works together with LocalStorage. It creates two-way data synchronization with an attribute in AppStorage. class PropB { code: number; constructor(code: number) { this.code = code; } } AppStorage.setOrCreate('PropA', 47); AppStorage.setOrCreate('PropB', new PropB(50)); let storage = new LocalStorage(); storage.setOrCreate('PropA', 48); storage.setOrCreate('PropB', new PropB(100)); @Entry(storage) @Component struct CompA { @StorageLink('PropA') storageLink: number = 1; @LocalStorageLink('PropA') localStorageLink: number = 1; @StorageLink('PropB') storageLinkObject: PropB = new PropB(1); @LocalStorageLink('PropB') localStorageLinkObject: PropB = new PropB(1); build() { Column({ space: 20 }) { Text(`From AppStorage ${this.storageLink}`) .onClick(() =&gt; { this.storageLink += 1; }) Text(`From LocalStorage ${this.localStorageLink}`) .onClick(() =&gt; { this.localStorageLink += 1; }) Text(`From AppStorage ${this.storageLinkObject.code}`) .onClick(() =&gt; { this.storageLinkObject.code += 1; }) Text(`From LocalStorage ${this.localStorageLinkObject.code}`) .onClick(() =&gt; { this.localStorageLinkObject.code += 1; }) } } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/appstorage.html#use-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/appstorage.html#use-scenarios"
  },"9": {
    "doc": "ArkTS Basics",
    "title": "The Basics",
    "content": "Text from source . Declarations . | Variable Declaration | Constant Declaration | Automatic Type Inference | . Types . | Numberic Types | Boolean | Void | Object | Array | Enum | Union | Type Aliases | . Operators . | Assignment Operrators | Comparison Operators | Arithmetic Operators | Bitwise Operators | Logical Operators | . Statements . | If | Switch | Conditional Expressions | For | For-of | While | Do-while | Break | Continue | Throw and Try | . Functions . | Function Declarations | Optional Parameters | The Rest Parameter | Return Types | Function Scope | Function Calls | . Function Types . | Arrow Functions(Lambdas Functions) | Closure | Function Overload Signature | . Classes . | Fields . | Instance Fields | Static Fields | Field Initializers | Getters and Setters | . | Methods . | Instance Methods . | Static Methods | Inheritance | Access to Super | Override Methods | Method Overload Signatures | . | Constructors . | Constructors in Derived Class | Constructor Overload Signatures | . | Visibility Modifiers . | Public Visibility | . | Private Visibility . | Protected Visibility | . | Object Literals . | Object Literals of Record Type | . | Abstract Classes . | Abstract Methods | . | . Interfaces . | Interface Properties | Interface Inheritance | Abstract class and interface | . Generic Types and Functions . | Generic Classes and Interfaces | Generic Constraints | Generic Functions | Generic Defaults | . Null Safety . | Non-Null Assertion Operator | Null-Coalescing Operator | Optional Chaining | . Modules . | Export | Import . | Static Import | Dynamic Import | . | Top-Level Statements | . Keywords . | this | . Declarations . Declarations in ArkTS introduce: . | Variables | Constants | Functions | Types | . Variable Declaration . A declaration starting with the keyword let introduces a variable which can have different values during program execution. let hi: string = 'hello'; hi = 'hello, world'; . Constant Declaration . A declaration starting with the keyword const introduces a read-only constant that can be assigned only once. const hello: string = 'hello'; . A compile-time error occurs if a new value is assigned to a constant. Automatic Type Inference . As ArkTS is a statically typed language, the types of all entities, like variables and constants, have to be known at compile time. However, developers do not need to explicitly specify the type of a declared entity if a variable or a constant declaration contains an initial value. All cases that allow the type to be inferred automatically are specified in the ArkTS Specification. Both variable declarations are valid, and both variables are of the string type: . let hi1: string = 'hello'; let hi2 = 'hello, world'; . Types . Numeric Types . ArkTS has numeric types. Any integer and floating-point values can be assigned to a variable of these types. Numeric literals include integer literals and floating-point literals with the decimal base. Integer literals include the following: . | Decimal integers that consist of a sequence of digits. For example: 0, 117, -345. | Hexadecimal integers that start with 0x (or 0X), and can contain digits (0-9) and letters a-f or A-F. For example: 0x1123, 0x00111, -0xF1A7. | Octal integers that start with 0o (or 0O) and can only contain digits (0-7). For example: 0o777. | Binary integers that start with 0b (or 0B), and can only contain the digits 0 and 1. For example: 0b11, 0b0011, -0b11. | . A floating-point literal includes the following: . | Decimal integer, optionally signed (i.e., prefixed with “+” or “-“); | Decimal point (“.”). | Fractional part (represented by a string of decimal digits). | Exponent part that starts with “e” or “E”, followed by an optionally signed (i.e., prefixed with “+” or “-“) integer. | . Example: . let n1 = 3.14; let n2 = 3.141592; let n3 = .5; let n4 = 1e2; function factorial(n: number): number { if (n &lt;= 1) { return 1; } return n * factorial(n - 1); } factorial(n1) // 7.660344000000002 factorial(n2) // 7.680640444893748 factorial(n3) // 1 factorial(n4) // 9.33262154439441e+157 . The number type tends to lose precision when it represents very large integers. You can use BigInt to ensure the precision as required. let bigIntger: BigInt = BigInt('999999999999999999999999999999999999999999999999999999999999'); console.log('bigIntger' + bigIntger.toString()); . Boolean . The boolean type represents logical values that are either true or false. Usually variables of this type are used in conditional statements: . let isDone: boolean = false; // ... if (isDone) { console.log ('Done!'); } . String . A string is a sequence of characters; some characters can be set by using escape sequences. A string literal consists of zero or more characters enclosed in single (‘) or double quotes (“). The special form of string literals are template literals enclosed in backtick quotes (`). let s1 = 'Hello, world!\\n'; let s2 = 'this is a string'; let a = 'Success'; let s3 = `The result is ${a}`; . Void Type . The void type is used to specify that a function does not return a value. This type has the only one value which is also void. As void is a reference type, it can be used as type argument for generic types. class Class&lt;T&gt; { //... } let instance: Class &lt;void&gt; . Object Type . An Object class type is a base type for all reference types. Any value, including values of primitive types (they will be automatically boxed), can be directly assigned to variables of the type Object.`The ‘object’ type is used to represent types other than the primitive types. Array Type . An array is an object comprised of elements of data types assignable to the element type specified in the array declaration. A value of an array is set by using array composite literal, that is a list of zero or more expressions enclosed in square brackets ([]). Each expression represents an element of the array. The length of the array is set by the number of expressions. Index of the first array element is 0. The following example creates the array with three elements: . let names: string[] = ['Alice', 'Bob', 'Carol']; . Enum Type . An enum type is a value type with a defined set of named values called enum constants. In order to be used, an enum constant must be prefixed with an enum type name. enum ColorSet { Red, Green, Blue } let c: ColorSet = ColorSet.Red; . A constant expression can be used to explicitly set the value of an enum constant. enum ColorSet { White = 0xFF, Grey = 0x7F, Black = 0x00 } let c: ColorSet = ColorSet.Black . Union Type . A union type is a reference type which is created as a combination of other types. Values of union types can be valid values of all types a union was created from. class Cat { name: string = 'cat'; // ... } class Dog { name: string = 'dog'; // ... } class Frog { name: string = 'frog'; // ... } type Animal = Cat | Dog | Frog | number // Cat, Dog, and Frog are some types (class or interface ones) let animal: Animal = new Cat(); animal = new Frog(); animal = 42; // One may assign the variable of the union type with any valid value . There are different mechanisms to get a value of a particular type from a union. Example: . class Cat { sleep () {}; meow () {} } class Dog { sleep () {}; bark () {} } class Frog { sleep () {}; leap () {} } type Animal = Cat | Dog | Frog; function foo(animal: Animal) { if (animal instanceof Frog) { animal.leap(); // animal is of type Frog here } animal.sleep(); // Any animal can sleep } . Type Aliases . Type aliases provides names for anonymous types (array, function, object literal or union types) or alternative names for existing types. type Matrix = number[][]; type Handler = (s: string, no: number) =&gt; string; type Predicate &lt;T&gt; = (x: T) =&gt; boolean; type NullableObject = Object | null; . Operators . Assignment Operators . Simple assignment operator ‘=’ is used as in “x = y”. Compound assignment operators combine an assignment with an operator, where x op = y equals x = x op y. Compound assignment operators are as follows: +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;&gt;=, &amp;=, |=, ^=. Comparison Operators . | Operator | Description | . | === | Returns true if both operands are strict equal. | . | !== | Returns true if both operands are nots trict equal. | . | == | Returns true if both operands are equal. | . | != | Returns true if both operands are not equal. | . | &gt; | Returns true if the left operand is greater than the right. | . | &gt;= | Returns true if the left operand is greater than or equal to the right. | . | &lt; | Returns true if the left operand is less than the right. | . | &lt;= | Returns true if the left operand is less than or equal to the right. | . Arithmetic Operators . Unary operators are -, +, -- and ++. Binary operators are as follows: . | Operator | Description | . | + | addition | . | - | subtraction | . | * | multiplication | . | / | division | . | % | remainder after division | . Bitwise Operators . | Operator | Description | . | a &amp; b | Bitwise AND: sets each bit to 1 if the corresponding bits of both operands are 1, otherwise to 0. | . | a \\| b | Bitwise OR: sets each bit to 1 if at least one of the corresponding bits of both operands is 1, otherwise to 0. | . | a ^ b | Bitwise XOR: sets each bit to 1 if the corresponding bits of both operands are different, otherwise to 0. | . | ~ a | Bitwise NOT: inverts the bits of the operand. | . | a &lt;&lt; b | Shift left: shifts the binary representation of a to the left by b bits. | . | a &gt;&gt; b | Arithmetic right shift: shifts the binary representation of a to the right by b bits with sign-extension. | . | a &gt;&gt;&gt; b | Logical right shift: shifts the binary representation of a to the right by b bits with zero-extension. | . Logical Operators . | Operator | Description | . | a &amp;&amp; b | Logical AND | . | a \\|\\| b | Logical OR | . | ! a | Logical NOT | . Statements . If Statements . An if statement is used to execute a sequence of statements when a logical condition is true, or another set of statements (if provided) otherwise. The else part can also contain more if statements. An if statement looks as follows: . if (condition1) { // statements1 } else if (condition2) { // statements2 } else { // else_statements } . All conditional expressions must be of the type boolean or other types (string, number, etc.). For types other than boolean, implicit conversion rules apply: . let s1 = 'Hello'; if (s1) { console.log(s1); // prints 'Hello' } let s2 = 'World'; if (s2.length != 0) { console.log(s2); // prints 'World' } . Switch Statements . A switch statement is used to execute a sequence of statements that match the value of a switch expression. A switch statement looks as follows: . switch (expression) { case label1: // will be executed if label1 is matched // ... // statements1 // ... break; // Can be omitted case label2: case label3: // will be executed if label2 or label3 is matched // ... // statements23 // ... break; // Can be omitted default: // default_statements } . If the value of a switch expression equals the value of some label, then the corresponding statements are executed. If there is no match, and the switch has the default clause, then the default statements are executed. An optional break statement allows you to break out of the switch and continue executing the statement that follows the switch. If there is no break, then the next statements in the switch are executed. Conditional Expressions . The conditional expression ? : uses the boolean value of the first expression to decide which of two other expressions to evaluate. A conditional expression looks as follows: . condition ? expression1 : expression2 . If that logical expression is truthy (a value that is considered true), then the first expression is used as the result of the ternary expression; otherwise, the second expression is used. Example: . let message = Math.random() &gt; 0.5 ? 'Valid' : 'Failed'; . For Statements . A for statement is executed repeatedly until the specified loop exit condition is false. A for statement looks as follows: . for ([init]; [condition]; [update]) { statements } . When a for statement is executed, the following process takes place: . | An init expression is executed, if any. This expression usually initializes one or more loop counters. | The condition is evaluated. If the value of condition is truthy(a value that is considered true), or if the conditional expression is omitted, then the statements in the for body are to be executed. If the value of condition is falsy(a value that is considered false), then the for loop terminates. | The statements of the for body are executed. | If there is an update expression, then the update expression is executed. | Go back to step 2. | . Example: . let sum = 0; for (let i = 0; i &lt; 10; i += 2) { sum += i; } . For-of Statements . for-of statements are used to iterate over an array or string. A for-of statement looks as follows: . for (forVar of expression) { statements } . Example: . for (let ch of 'a string object') { /* process ch */ } . While Statements . A while statement has its body statements executed as long as the specified condition evaluates to true. A while statement looks as follows: . while (condition) { statements } . Example: . let n = 0; let x = 0; while (n &lt; 3) { n++; x += n; } . Do-while Statements . do-while statements are executed repetitively until a specified condition evaluates to false. A do-while statement looks as follows: . do { statements } while (condition) . Example: . let i = 0; do { i += 1; } while (i &lt; 10) . Break Statements . A break statement is used to terminate any loop statement or switch. Example: . let x = 0; while (true) { x++; if (x &gt; 5) { break; } } . A break statement with a label identifier transfers control out of the enclosing statement to the one which has the same label identifier. Example: . let x = 1; label: while (true) { switch (x) { case 1: // statements break label; // breaks the while } } . Continue Statements . A continue statement stops the execution of the current loop iteration and passes control to the next iteration. Example: . let sum = 0; for (let x = 0; x &lt; 100; x++) { if (x % 2 == 0) { continue; } sum += x; } . Throw and Try Statements . A throw statement is used to throw an exception or an error: . throw new Error('this error') . A try statement is used to catch and handle an exception or an error: . try { // try block } catch (e) { // handle the situation } . The example below shows the throw and try statements used to handle the zero division case: . class ZeroDivisor extends Error {} function divide (a: number, b: number): number{ if (b == 0) throw new ZeroDivisor(); return a / b; } function process (a: number, b: number) { try { let res = divide(a, b); console.log('result: ' + res); } catch (x) { console.log('some error'); } } . finally clause is also supported: . function processData(s: string) { let error: Error | null = null; try { console.log('Data processed: ' + s); // ... // Throwing operations // ... } catch (e) { error = e as Error; // ... // More error handling // ... } finally { if (error != null) { console.log(`Error caught: input='${s}', message='${error.message}'`); } } } . Functions . Function Declarations . A function declaration introduces a named function, specifying its name, parameters, return type and body. Below is a simple function with two string parameters and string return type: . function add(x: string, y: string): string { let z: string = `${x} ${y}`; return z; } . For every parameter its type annotation must be specified. An optional parameter allows you to omit the corresponding argument when calling a function. The last parameter of a function can be a rest parameter. Optional Parameters . An optional parameter has the form name?: Type. function hello(name?: string) { if (name == undefined) { console.log('Hello!'); } else { console.log(`Hello, ${name}!`); } } . Another form contains an expression that specifies a default value. If the corresponding argument to such parameter is omitted in a function call, then this parameter’s value is default. function multiply(n: number, coeff: number = 2): number { return n * coeff; } multiply(2); // returns 2*2 multiply(2, 3); // returns 2*3 . The Rest Parameter . The last parameter of a function can be a rest parameter. It allows functions or methods to take unlimited number of arguments. function sum(...numbers: number[]): number { let res = 0; for (let n of numbers) res += n; return res; } sum(); // returns 0 sum(1, 2, 3); // returns 6 . Return Types . If function return type can be inferred from its body content, then it can be omitted from the function declaration. // Explicit return type function foo(): string { return 'foo'; } // Implicit return type inferred as string function goo() { return 'goo'; } . The return type of a function that does not need to return a value can be explicitly specified as void or omitted altogether. No return statement is needed for such functions. Both notations below are valid: . function hi1() { console.log('hi'); } function hi2(): void { console.log('hi'); } . Function Scope . Variables and other entities defined in a function are local to the function and cannot be accessed from the outside. If the name of a variable defined in the function is equal to the name of an entity in the outer scope, then the local definition shadows the outer entity. Function Calls . Calling a function actually leads to the execution of its body, while the arguments of the call are assigned to the function parameters. If the function is defined as follows: . function join(x: string, y: string): string { let z: string = `${x} ${y}`; return z; } . then it is called with two arguments of the type string: . let x = join('hello', 'world'); console.log(x); . Function Types . Function types are commonly used as follows to define callbacks: . type trigFunc = (x: number) =&gt; number // this is a function type function do_action(f: trigFunc) { f(3.141592653589); // call the function } do_action(Math.sin); // pass the function as the parameter . Arrow Functions (Lambdas Functions) . A function can be defined as an arrow function, for example: . let sum = (x: number, y: number): number =&gt; { return x + y; } . An arrow function return type can be omitted; in such case, it is inferred from the function body. An expression can be specified as an arrow function to make the notation shorter, i.e., the following two notations are equivalent: . let sum1 = (x: number, y: number) =&gt; { return x + y; } let sum2 = (x: number, y: number) =&gt; x + y . Closure . A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created. In the following example, z is a reference to the instance of the function g that is created when f is executed. The instance of g maintains a reference to its lexical environment, within which the variable count exists. For this reason, when z is invoked, the variable count remains available for use. function f(): () =&gt; number { let count = 0; let g = (): number =&gt; { count++; return count; }; return g; } let z = f(); z(); // output: 1 z(); // output: 2 . Function Overload Signatures . A function can be specified to be called in different ways by writing overload signatures. To do so, several functions’ headers that have the same name but different signatures are written and immediately followed by the single implementation function. function foo(x: number): void; /* 1st signature */ function foo(x: string): void; /* 2nd signature */ function foo(x: number | string): void { /* Implementation signature */ } foo(123); // ok, 1st signature is used foo('aa'); // ok, 2nd signature is used . An error occurs if two overload signatures have identical parameter lists. Classes . A class declaration introduces a new type and defines its fields, methods and constructors. In the following example, class Person is defined, which has fields name and surname, constructor, and a method fullName: . class Person { name: string = ''; surname: string = ''; constructor (n: string, sn: string) { this.name = n; this.surname = sn; } fullName(): string { return this.name + ' ' + this.surname; } } . After the class is defined, its instances can be created by using the keyword new: . let p = new Person('John', 'Smith'); console.log(p.fullName()); . or an instance can be created by using object literals: . class Point { x: number = 0; y: number = 0; } let p: Point = {x: 42, y: 42}; . Fields . A field is a variable of some type that is declared directly in a class. Classes may have instance fields, static fields or both. Instance Fields . Instance fields exist on every instance of a class. Each instance has its own set of instance fields. An instance of the class is used to access an instance field. class Person { name: string = ''; age: number = 0; constructor(n: string, a: number) { this.name = n; this.age = a; } getName(): string { return this.name; } } let p1 = new Person('Alice', 25); p1.name; let p2 = new Person('Bob', 28); p2.getName(); . Static Fields . The keyword static is used to declare a field as static. Static fields belong to the class itself, and all instances of the class share one static field. The class name is used to access a static field: . class Person { static numberOfPersons = 0; constructor() { // ... Person.numberOfPersons++; // ... } } Person.numberOfPersons; . Field Initializers . ArkTS requires that all fields are explicitly initialized with some values either when the field is declared or in the constructor. This is similar to strictPropertyInitialization mode of the standard TypeScript. Such behavior is enforced to minimize the number of unexpected runtime errors and achieve better performance. The following code (invalid in ArkTS) is error-prone: . class Person { name: string; // undefined setName(n:string): void { this.name = n; } getName(): string { // Return type \"string\" hides from the developers the fact // that name can be undefined. The most correct would be // to write the return type as \"string | undefined\". By doing so // we tell the users of our API about all possible return values. return this.name; } } let jack = new Person(); // Let's assume that the developer forgets to call setName: // jack.setName('Jack') jack.getName().length; // runtime exception: name is undefined . Here is how it should look in ArkTS: . class Person { name: string = ''; setName(n:string): void { this.name = n; } // The type is always string, no other \"hidden options\". getName(): string { return this.name; } } let jack = new Person(); // Let's assume that the developer forgets to call setName: // jack.setName('Jack') jack.getName().length; // 0, no runtime error . And here how our code behaves if the field name can be undefined . class Person { name?: string; // The field may be undefined setName(n:string): void { this.name = n; } // Compile-time error: // name can be \"undefined\", so we cannot say to those who use this API // that it returns only strings: getNameWrong(): string { return this.name; } getName(): string | undefined { // Return type matches the type of name return this.name; } } let jack = new Person() // Let's assume that the developer forgets to call setName: // jack.setName('Jack') // Compile-time(!) error: Compiler suspects that we // may possibly access something undefined and won't build the code: jack.getName().length; // The code won't build and run jack.getName()?.length; // Builds ok, no runtime error . Getters and Setters . Setters and getters can be used to provide controlled access to object properties. In the following example, a setter is used to forbid setting invalid values of the ‘_age’ property: . class Person { name: string = ''; private _age: number = 0; get age(): number { return this._age; } set age(x: number) { if (x &lt; 0) { throw Error('Invalid age argument'); } this._age = x; } } let p = new Person(); p.age; // 0 p.age = -42; // Error will be thrown as an attempt to set incorrect age . A class can define a getter, a setter or both. Methods . A method is a function that belongs to a class. A class can define instance methods, static methods or both. A static method belongs to the class itself, and can have access to static fields only. A while instance method has access to both static (class) fields and instance fields including private ones of its class. Instance Methods . The example below illustrates how instanced methods work. The calculateArea method calculates the area of a rectangle by multiplying the height by the width: . class RectangleSize { private height: number = 0; private width: number = 0; constructor(height: number, width: number) { this.height = height; this.width = width; } calculateArea(): number { return this.height * this.width; } } . To use an instance method, it must be called on an instance of the class: . let square = new RectangleSize(10, 10); square.calculateArea(); // output: 100 . Static Methods . The keyword static is used to declare a method as static. Static methods belong to the class itself and have access to static fields only. A static method defines a common behavior of the class as a whole. The class name is used to call a static method: . class Cl { static staticMethod(): string { return 'this is a static method.'; } } console.log(Cl.staticMethod()); . Inheritance . A class can extend another class. The class that is being extended by another class is called ‘base class’, ‘parent class’, or ‘superclass’. The class that extends another class is called ‘extended class’, ‘derived class’, or ‘subclass’. An extended class can implement several interfaces by using the following syntax: . class [extends BaseClassName] [implements listOfInterfaces] { // ... } . An extended class inherits fields and methods, but not constructors from the base class, and can add its own fields and methods, as well as override methods defined by the base class. Example: . class Person { name: string = ''; private _age = 0; get age(): number { return this._age; } } class Employee extends Person { salary: number = 0; calculateTaxes(): number { return this.salary * 0.42; } } . A class containing the implements clause must implement all methods defined in all listed interfaces, except the methods defined with default implementation. interface DateInterface { now(): string; } class MyDate implements DateInterface { now(): string { // implementation is here return 'now'; } } . Access to Super . The keyword super can be used to access instance fields, instance methods and constructors from the super class. It is often used to extend basic functionality of subclass with the required behavior taken from the super class: . class RectangleSize { protected height: number = 0; protected width: number = 0; constructor (h: number, w: number) { this.height = h; this.width = w; } draw() { /* draw bounds */ } } class FilledRectangle extends RectangleSize { color = '' constructor (h: number, w: number, c: string) { super(h, w); // call of super constructor this.color = c; } draw() { super.draw(); // call of super methods // super.height - can be used here /* fill rectangle */ } } . Override Methods . A subclass can override implementation of a method defined in its superclass. An overridden method must have the same types of parameters, and same or derived return type as the original method. class RectangleSize { // ... area(): number { // implementation return 0; } } class Square extends RectangleSize { private side: number = 0; area(): number { return this.side * this.side; } } . Method Overload Signatures . A method can be specified to be called in different ways by writing overload signatures. To do so, several method headers that have the same name but different signatures are written and immediately followed by the single implementation method. class C { foo(x: number): void; /* 1st signature */ foo(x: string): void; /* 2nd signature */ foo(x: number | string): void { /* implementation signature */ } } let c = new C(); c.foo(123); // ok, 1st signature is used c.foo('aa'); // ok, 2nd signature is used . An error occurs if two overload signatures have the same name and identical parameter lists. Constructors . A class declaration may contain a constructor that is used to initialize object state. A constructor is defined as follows: . constructor ([parameters]) { // ... } . If no constructor is defined, then a default constructor with an empty parameter list is created automatically, for example: . class Point { x: number = 0; y: number = 0; } let p = new Point(); . In this case the default constructor fills the instance fields with default values for the field types. Constructors in Derived Class . The first statement of a constructor body can use the keyword super to explicitly call a constructor of the direct superclass. class RectangleSize { constructor(width: number, height: number) { // ... } } class Square extends RectangleSize { constructor(side: number) { super(side, side); } } . Constructor Overload Signatures . A constructor can be specified to be called in different ways by writing overload signatures. To do so, several constructor headers that have the same name but different signatures are written and immediately followed by the single implementation constructor. class C { constructor(x: number) /* 1st signature */ constructor(x: string) /* 2nd signature */ constructor(x: number | string) { /* Implementation signature */ } } let c1 = new C(123); // ok, 1st signature is used let c2 = new C('abc'); // ok, 2nd signature is used . An error occurs if two overload signatures have the same name and identical parameter lists. Visibility Modifiers . Both methods and properties of a class can have visibility modifiers. There are several visibility modifiers: . | private | protected | public | . The default visibility is public. Public Visibility . The public members (fields, methods, constructors) of a class are visible in any part of the program, where their class is visible. Private Visibility . A private member cannot be accessed outside the class it is declared in. Example: . class C { public x: string = ''; private y: string = ''; set_y (new_y: string) { this.y = new_y // ok, as y is accessible within the class itself } } let c = new C(); c.x = 'a'; // ok, the field is public c.y = 'b'; // compile-time error: 'y' is not visible . Protected Visibility . The modifier protected acts much like the modifier private, but the protected members are also accessible in derived classes. Example: . class Base { protected x: string = ''; private y: string = ''; } class Derived extends Base { foo() { this.x = 'a'; // ok, access to protected member this.y = 'b'; // compile-time error, 'y' is not visible, as it is private } } . Object Literals . An object literal is an expression that can be used to create a class instance and provide some initial values. It can be used instead of the expression new as it is more convenient in some cases. A class composite is written as a comma-separated list of name-value pairs enclosed in ‘{‘ and ‘}’. class C { n: number = 0; s: string = ''; } let c: C = {n: 42, s: 'foo'}; . Due to the static typing of the ArkTS, object literals can be used in a context where the class or interface type of the object literal can be inferred as in the example above. Other valid cases are illustrated below: . class C { n: number = 0; s: string = ''; } function foo(c: C) {} let c: C; c = {n: 42, s: 'foo'}; // type of the variable is used foo({n: 42, s: 'foo'}); // type of the parameter is used function bar(): C { return {n: 42, s: 'foo'}; // return type is used } . The type of an array element or of a class field can also be used: . class C { n: number = 0; s: string = ''; } let cc: C[] = [{n: 1, s: 'a'}, {n: 2, s: 'b'}]; . Object Literals of Record Type . The generic Record&lt;K, V&gt; type is used to map the properties of a type (Key type) to another type (Value type). A special form of object literal is used to initialize the value of such type: . let map: Record&lt;string, number&gt; = { 'John': 25, 'Mary': 21, } map['John']; // 25 . The K type can be either string or number, while V can be any type. interface PersonInfo { age: number; salary: number; } let map: Record&lt;string, PersonInfo&gt; = { 'John': { age: 25, salary: 10}, 'Mary': { age: 21, salary: 20} } . Abstract Classes . A class with the modifier abstract is known as abstract class. Abstract classes can be used to represent notions that are common to some set of more concrete notions. A compile-time error occurs if an attempt is made to create an instance of an abstract class: . abstract class X { field: number; constructor(p: number) { this.field = p; } } let x = new X(666) // Compile-time error: Cannot create an instance of an abstract class. Subclasses of an abstract class can be non-abstract or in turn abstract. A non-abstract subclass of an abstract superclass can be instantiated. As a result, a constructor for the abstract class, and field initializers for non-static fields of that class are executed： . abstract class Base { field: number; constructor(p: number) { this.field = p; } } class Derived extends Base { constructor(p: number) { super(p); } } . Abstract Methods . A method with the modifier abstract is considered an abstract method. Abstract methods do not have bodies, i.e., they can be declared but not implemented. Only abstract classes can have abstract methods. A compile-time error occurs if a non-abstract class has an abstract method: . class Y { abstract method(p: string) //Compile-time error: Abstract methods can only appear within an abstract class. } . Interfaces . An interface declaration introduces a new type. Interfaces are a common way of defining contracts between various part of codes. Interfaces are used to write polymorphic code, which can be applied to any class instances that implement a particular interface. An interface usually contains properties and method headers. Examples: . interface Style { color: string; // property } interface AreaSize { calculateAreaSize(): number; // method header someMethod(): void; // method header } . Examples of a class implementing an interface: . // Interface: interface AreaSize { calculateAreaSize(): number; // method header someMethod(): void; // method header } // Implementation: class RectangleSize implements AreaSize { private width: number = 0; private height: number = 0; someMethod(): void { console.log('someMethod called'); } calculateAreaSize(): number { this.someMethod(); // calls another method and returns result return this.width * this.height; } } . Interface Properties . An interface property can be in a form of field, getter, setter, or both getter and setter. A property field is just a shortcut notation of a getter/setter pair, and the following notations are equal: . interface Style { color: string; } . interface Style { get color(): string set color(x: string) } . A class that implements an interface may also use a short or a long notation: . interface Style { color: string; } class StyledRectangle implements Style { color: string = ''; } . interface Style { color: string; } class StyledRectangle implements Style { private _color: string = ''; get color(): string { return this._color; } set color(x: string) { this._color = x; } } . Interface Inheritance . An interface may extend other interfaces like in the example below: . interface Style { color: string; } interface ExtendedStyle extends Style { width: number; } . An extended interface contains all properties and methods of the interface it extends, and can also add its own properties and methods. Abstract class and interface . Abstract classes and interfaces cannot be instantiated. Abstract classes are abstractions of classes, used to capture the general characteristics of subclasses, and interfaces are abstractions of behavior. The difference between abstract classes and interfaces in ArkTS is as follows: . | Abstract classes can only inherit from a single source, while interfaces can be implemented in multiple layers; | In abstract classes, there can be implementations of methods, but interfaces are completely abstract and there is no implementation of methods; | The interface cannot contain static code blocks and static methods, while abstract classes can have static code blocks and static functions; | Abstract classes can have constructors, while interfaces cannot have constructors. | . Generic Types and Functions . Generic types and functions allow creating the code capable to work over a variety of types rather than a single type. Generic Classes and Interfaces . A class and an interface can be defined as generics, adding parameters to the type definition, like the type parameter Element in the following example: . class CustomStack&lt;Element&gt; { public push(e: Element):void { // ... } } . To use type CustomStack, the type argument must be specified for each type parameter: . let s = new CustomStack&lt;string&gt;(); s.push('hello'); . Compiler ensures type safety while working with generic types and functions. See below: . let s = new CustomStack&lt;string&gt;(); s.push(55); // That will be a compile-time error as 55 is not compatible with type string. Generic Constraints . Type parameters of generic types can be bounded. For example, the Key type parameter in the MyHashMap&lt;Key, Value&gt; container must have the hash method. interface Hashable { hash(): number; } class MyHashMap&lt;Key extends Hashable, Value&gt; { public set(k: Key, v: Value) { let h = k.hash(); // ... other code ... } } . In the above example, the Key type extends Hashable, and all methods of Hashable interface can be called for keys. Generic Functions . Use a generic function to create a more universal code. Consider a function that returns the last element of the array: . function last(x: number[]): number { return x[x.length - 1]; } last([1, 2, 3]); // output: 3 . If the same function needs to be defined for any array, then define it as a generic with a type parameter: . function last&lt;T&gt;(x: T[]): T { return x[x.length - 1]; } . Now, the function can be used with any array. In a function call, type argument can be set explicitly or implicitly: . // Explicit type argument last&lt;string&gt;(['aa', 'bb']); last&lt;number&gt;([1, 2, 3]); // Implicit type argument: // Compiler understands the type argument based on the type of the call arguments last([1, 2, 3]); . Generic Defaults . Type parameters of generic types can have defaults. It allows using just the generic type name instead of specifying the actual type arguments. The example below illustrates this for both classes and functions. class SomeType {} interface Interface &lt;T1 = SomeType&gt; { } class Base &lt;T2 = SomeType&gt; { } class Derived1 extends Base implements Interface { } // Derived1 is semantically equivalent to Derived2 class Derived2 extends Base&lt;SomeType&gt; implements Interface&lt;SomeType&gt; { } function foo&lt;T = number&gt;(): T { // ... } foo(); // such function is semantically equivalent to the call below foo&lt;number&gt;(); . Null Safety . All types in ArkTS by default are non-nullable, so the value of a type cannot be null. It is similar to TypeScript behavior in strict null checking mode (strictNullChecks), but the rules are stricter. In the example below, all lines cause a compile-time error: . let x: number = null; // Compile-time error let y: string = null; // Compile-time error let z: number[] = null; // Compile-time error . A variable that can have a null value is defined with a union type T | null. let x: number | null = null; x = 1; // ok x = null; // ok if (x != null) { /* do something */ } . Non-Null Assertion Operator . A postfix operator ! can be used to assert that its operand is non-null. If applied to a null value, the operator throws an error. Otherwise, the type of the value is changed from T | null to T: . class A { value: number = 0; } function foo(a: A | null) { a.value; // compile time error: cannot access to a nullable value // ok, if the value of a is not null at runtime, the fields of a can be accessed; // If the value of runtime a is empty, a runtime exception occurs. a!.value; } . Null-Coalescing Operator . The null-coalescing binary operator ?? checks whether the evaluation of the left-hand-side expression is equal to null or undefined. If it is, then the result of the expression is the right-hand-side expression; otherwise, it is the left-hand-side expression. In other words, a ?? b equals the ternary operator (a != null &amp;&amp; a != undefined) ? a : b. In the following example, the method getNick returns a nickname if it is set; otherwise, an empty string is returned: . class Person { // ... nick: string | null = null; getNick(): string { return this.nick ?? ''; } } . Optional Chaining . Optional chaining operator ?. allows writing code where the evaluation stops at an expression that is partially evaluated to null or undefined. class Person { nick: string | null = null; spouse?: Person; setSpouse(spouse: Person): void { this.spouse = spouse; } getSpouseNick(): string | null | undefined { return this.spouse?.nick; } constructor(nick: string) { this.nick = nick; this.spouse = undefined; } } . Note: The return type of getSpouseNick must be string | null | undefined, as the method can return null or undefined. An optional chain can be of any length and contain any number of ?. operators. In the following sample, the output is a person’s spouse nickname if that person has a spouse, and the spouse has a nickname. Otherwise, the output is undefined: . class Person { nick: string | null = null; spouse?: Person; constructor(nick: string) { this.nick = nick; this.spouse = undefined; } } let p: Person = new Person('Alice'); p.spouse?.nick; // undefined . Modules . Programs are organized as sets of compilation units or modules. Each module creates its own scope, i.e., any declarations (variables, functions, classes, etc.) declared in the module are not visible outside that module unless they are explicitly exported. Conversely, a variable, function, class, interface, etc. exported from another module must first be imported to a module. Export . A top-level declaration can be exported by using the keyword export. A declared name that is not exported is considered private and can be used only in the module where it is declared. export class Point { x: number = 0; y: number = 0; constructor(x: number, y: number) { this.x = x; this.y = y; } } export let Origin = new Point(0, 0); export function Distance(p1: Point, p2: Point): number { return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y)); } . Import . Static Import . Import declarations are used to import entities exported from other modules and provide their bindings in the current module. An import declaration consists of two parts: . | Import path that determines the module to import from. | Import bindings that define the set of usable entities in the imported module, and the form of use (i.e., qualified or unqualified use). | . Import bindings may have several forms. Let’s assume a module has the path ‘./utils’ and export entities ‘X’ and ‘Y’. An import binding of the form * as A binds the name ‘A’, and all entities exported from the module defined by the import path can be accessed by using the qualified name A.name: . import * as Utils from './utils'; Utils.X // denotes X from Utils Utils.Y // denotes Y from Utils . An import binding of the form { ident1, ..., identN } binds an exported entity with a specified name, which can be used as a simple name: . import { X, Y } from './utils'; X // denotes X from Utils Y // denotes Y from Utils . If a list of identifiers contains aliasing of the form ident as alias, then entity ident is bound under the name alias: . import { X as Z, Y } from './utils'; Z // denotes X from Utils Y // denotes Y from Utils X // Compile-time error: 'X' is not visible . Dynamic Import . Unlike static import, static import allows you to load a module conditionally or on demand. The import() **syntax, commonly called dynamic import, is a function-like expression that allows for dynamic loading of a module. It returns a promise. In the following example, **import(modulePath) loads the module and returns a promise that resolves into a module object that contains all its exports. This expression can be called from any place in the code. // Calc.ts export function add(a:number, b:number):number { let c = a + b; console.info('Dynamic import, %d + %d = %d', a, b, c); return c; } // Index.ts import(\"./Calc\").then((obj: ESObject) =&gt; { console.info(obj.add(3, 5)); }).catch((err: Error) =&gt; { console.error(\"Module dynamic import error: \", err); }); . You can also use let module = await import(modulePath) inside an async function. // say.ts export function hi() { console.log('Hello'); } export function bye() { console.log('Bye'); } . Then dynamic import can be like this: . async function test() { let ns = await import('./say'); let hi = ns.hi; let bye = ns.bye; hi(); bye(); } . Top-Level Statements . A module can contain any statements at the module level, except return ones. Keywords . this . The keyword this can only be used in instance methods of a class. Example . class A { count: string = 'a'; m(i: string): void { this.count = i; } } . Constraints: . | Type notation using this is not supported. | Using this inside standalone functions is not supported. | . Example . class A { n: number = 0; f1(arg1: this) {} // Compile-time error. Type notation using this is not supported. static f2(arg1: number) { this.n = arg1; // Compile-time error. Using this inside standalone functions is not supported. } } function foo(arg1: number) { this.n = i; // Compile-time error. Using this inside standalone functions is not supported. } . The keyword this used as a primary expression denotes a value that is a reference to the following: . | Object for which the instance method is called; or | Object being constructed. | . The value denoted by this in a lambda body and in the surrounding context is the same. ",
    "url": "/application-development/arkts-basics.html#the-basics",
    
    "relUrl": "/application-development/arkts-basics.html#the-basics"
  },"10": {
    "doc": "ArkTS Basics",
    "title": "ArkTS Basics",
    "content": " ",
    "url": "/application-development/arkts-basics.html",
    
    "relUrl": "/application-development/arkts-basics.html"
  },"11": {
    "doc": "Introduction to ArkUI",
    "title": "UI Development (ArkTS-based Declarative Development Paradigm) Overview",
    "content": "Powered by the ArkTS-based declarative development paradigm, ArkUI is a simplified, high-performance UI development framework for cross-device applications. It provides the capabilities required for building the application UI, including: . | ArkTS . ArkTS is the preferred programming language for application development in OpenHarmony. As a superset of TypeScript (TS for short), it contains all TS features and added features – declarative UI description, custom components, dynamic extension of UI elements, state management, and rendering control. State management provides clear page re-render processes and pipes through decorators with different functions. State management covers UI component states and application states, with which you are able to build an application-wide data update and UI rendering process. To learn more about ArkTS, see Getting Started with ArkTS. | Layout . The layout defines how components are laid out in the UI. ArkUI offers a diverse array of layouts. Besides the basic layouts – linear, stack, flex, relative, and grid, you also have access to the advanced list, grid, and swiper layouts. | Component . Components are essential elements of the UI, working together to shape the UI. They can be classified as built-in components – those directly provided by the ArkUI framework, and custom components – those defined by developers. The built-in components include buttons, radio buttons, progress indicators, and text. You can set the rendering effect of these components in method chaining mode. You can combine built-in components to form custom components. In this way, page components are divided into independent UI units to implement independent creation, development, and reuse of different units on pages, making pages more engineering-oriented. | Page routing and component navigation . An application may contain a good many pages, and each page may come with multiple components. You can implement page routing to navigate users between pages and use navigation component to navigate them between components. | Graphics . ArkUI offers diversified graphics capabilities, including capabilities to display images in various formats and custom drawing capabilities. By leveraging these capabilities, you can easily bring your custom drawing ideas into reality. | Animation . Apart from animations embedded in components, ArkUI offers additional animation features: attribute animation, explicit animation, transition animation, and animation APIs. You can customize animation tracks by calling the provided animation APIs in addition to using the encapsulated physical models. | Interaction event . Interaction events are important for interactions between the UI and users. ArkUI allows users to interact with your application UI, with support for various universal events and gesture events. Universal events include touch events, mouse events, key events, and focus events. Gesture events accept single gestures (tap, long press, pan, pinch, rotation, and swipe), and a combination of gestures. | . ",
    "url": "/application-development/basic-concepts/arkui-introduction.html#ui-development-arkts-based-declarative-development-paradigm-overview",
    
    "relUrl": "/application-development/basic-concepts/arkui-introduction.html#ui-development-arkts-based-declarative-development-paradigm-overview"
  },"12": {
    "doc": "Introduction to ArkUI",
    "title": "Highlights",
    "content": ". | Simplified and efficient development . | Simple code: You can describe the UI in pseudo-natural language, without caring about how the framework implements UI drawing and rendering. | Data-driven UI change: This allows you to better focus on your service logic processing. When the UI changes, you do not need to write code for switching between different UIs. Instead, you only need to write the data that causes the UI change and let the framework take over the rest. | Improved development experience: Just code to get the UI developed. | . | High performance . | Declarative UI frontend and backend layering: The UI backend, constructed using the C++ programming language, provides basic components, layout, animations, interaction events, component state management, and rendering pipelines for the frontend. | Language compiler and runtime optimization: The productivity punch includes unified bytecode, efficient Foreign Function Interface (FFI), ahead-of-time (AOT), engine minimization, and type optimization. | . | Promising ecosystem ArkUI can gain traction with its relatively neutral and friendly programming language. It can tap on the ecosystems of mainstream languages ecosystem and pushed toward a steady revolutionary path with standards organizations. | . ",
    "url": "/application-development/basic-concepts/arkui-introduction.html#highlights",
    
    "relUrl": "/application-development/basic-concepts/arkui-introduction.html#highlights"
  },"13": {
    "doc": "Introduction to ArkUI",
    "title": "Architecture",
    "content": "Figure 1 Overall architecture . | Declarative UI frontend Provides basic language specifications of the UI development paradigm, built-in UI components, layouts, and animations, and multiple state management mechanisms, with a wide array of APIs for you to call as required. | Language runtime Provides the parsing capability for the UI paradigm syntax and allows for cross-language API calls for a high-performance operating environment of the TS language. | Declarative UI backend engine Provides UI rendering pipelines that are compatible with different development paradigms, multiple basic components, layout calculation, dynamic effects, and interaction events, with state management and drawing capabilities. | Render engine Provides efficient drawing capabilities, which enable rendering instructions collected by the rendering pipeline to be drawn to the screen. | Platform adaptation layer Provides abstract APIs to connect to different systems, such as system rendering pipelines and lifecycle scheduling. | . ",
    "url": "/application-development/basic-concepts/arkui-introduction.html#architecture",
    
    "relUrl": "/application-development/basic-concepts/arkui-introduction.html#architecture"
  },"14": {
    "doc": "Introduction to ArkUI",
    "title": "Development Process",
    "content": "The table below lists the main tasks involved in UI development with ArkUI. You can familiarize yourself with the UI development process by getting started with a simple project. | Task | Description | Guide | . | Get started with ArkTS | Learn the basic syntax, state management, and rendering control scenarios of ArkTS. | - Basic Syntax Overview- State Management- Rendering Control | . | Develop the layout | Understand the common layouts. | - Layout Overview | . | Add components | Learn the usage of common built-in components, custom components, and GUI elements supported by APIs. | - Common Components- Custom Components- Popup and Menu | . | Set page routing and component navigation | Learn how to set page routes and navigation between components. | - Page Routing- Navigation | . | Use graphics | Understand how to display images, draw custom geometry, and make custom graphics on the canvas. | - Displaying Images- Drawing Geometric Shapes- Drawing Custom Graphics Using the Canvas | . | Apply animations | Learn the typical scenarios of applying animations on components and pages. | - Property Animation- Transition Animation- Component Animation- Animated Curve- Animation Smoothing- Animation Effects | . | Bind events | Learn the basic concepts of events and how to use common events and gesture events. | - Universal Events- Gesture Events | . ",
    "url": "/application-development/basic-concepts/arkui-introduction.html#development-process",
    
    "relUrl": "/application-development/basic-concepts/arkui-introduction.html#development-process"
  },"15": {
    "doc": "Introduction to ArkUI",
    "title": "Introduction to ArkUI",
    "content": " ",
    "url": "/application-development/basic-concepts/arkui-introduction.html",
    
    "relUrl": "/application-development/basic-concepts/arkui-introduction.html"
  },"16": {
    "doc": "Build the First Page",
    "title": "Build the First Page",
    "content": "​Now that you’re familiar with DevEco Studio, let’s create a simple application that demonstrates page navigation. Use the Text Component . ​After the project synchronization completes, navigate to entry &gt; ets &gt; pages in the Ohos window and open the Index.ets file. This file contains a Text component. The sample code in the Index.ets file is shown below:​ . // Index.ets @Entry @Component struct Index { @State message: string = 'Hello World'; build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) } .width('100%') } .height('100%') } } . Add a Button Component . On the Index page, add a Button component to handle user clicks and navigate to another page. The following sample code in Index.ets demonstrates this implementation: . // Index.ets @Entry @Component struct Index { @State message: string = 'Hello World'; build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) // Add a button to respond to user clicks. Button() { Text('Next') .fontSize(30) .fontWeight(FontWeight.Bold) } .type(ButtonType.Capsule) .margin({ top: 20 }) .backgroundColor('#0D9FFB') .width('40%') .height('5%') } .width('100%') } .height('100%') } } . Now you can observe how the first page looks like in the Previewer . ",
    "url": "/application-development/create-first-eclipse-oniro-app/build-first-page.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/build-first-page.html"
  },"17": {
    "doc": "Build the Second Page",
    "title": "Build the Second Page",
    "content": "Create the Second Page . | Right click entry &gt; ets &gt; pages folder, select New and choose Page. | . | Type ‘SecondPage’ as the new Page name. | . SecondPage created. Navigate to entry &gt; resources &gt; base &gt; profile, open main_pages.json you will find the page routes was configured automatically. // main_pages.json { \"src\": [ \"pages/Index\", \"pages/SecondPage\" ] } . Note: If you create the page in other methods, you have to manually configure the page routes in above path. Add Text and Button Components . Add Text and Button components with styled properties, using the first page as a reference. The sample code in Second.ets is shown below: . // SecondPage.ets @Entry @Component struct SecondPage { @State message: string = 'Second Page'; build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) Button() { Text('Back') .fontSize(25) .fontWeight(FontWeight.Bold) } .type(ButtonType.Capsule) .margin({ top: 20 }) .backgroundColor('#0D9FFB') .width('40%') .height('5%') } .width('100%') } .height('100%') } } . You can observe how the second page looks like in the Previewer . ",
    "url": "/application-development/create-first-eclipse-oniro-app/build-second-page.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/build-second-page.html"
  },"18": {
    "doc": "Code Editing",
    "title": "Keyboard Shortcuts",
    "content": "Being able to keep your hands on the keyboard when writing code is crucial for high productivity. You can explore various keyboard shortcuts by navigating to File -&gt; Preferences -&gt; Keyboard Shortcuts from the menu tab or clicking Ctrl+Alt+,. ",
    "url": "/device-development/oniro-ide/code-editing.html#keyboard-shortcuts",
    
    "relUrl": "/device-development/oniro-ide/code-editing.html#keyboard-shortcuts"
  },"19": {
    "doc": "Code Editing",
    "title": "Selection",
    "content": "Different selection options can be explored from Selection in the menu tab. A few of the important ones are Shift + Right/Left/Up/Down for basic selection, Ctrl + Shift + Right/Left for whole words selection, and column selection by placing the cursor in one corner and then holding Shift+Alt while dragging to the opposite corner. ",
    "url": "/device-development/oniro-ide/code-editing.html#selection",
    
    "relUrl": "/device-development/oniro-ide/code-editing.html#selection"
  },"20": {
    "doc": "Code Editing",
    "title": "Save &amp; Auto Save",
    "content": "To save a file press Ctrl+S or enable auto save from File -&gt; Auto Save which will save your changes after a configured delay or when focus leaves the editor. ",
    "url": "/device-development/oniro-ide/code-editing.html#save--auto-save",
    
    "relUrl": "/device-development/oniro-ide/code-editing.html#save--auto-save"
  },"21": {
    "doc": "Code Editing",
    "title": "Find &amp; Replace",
    "content": "Press Ctrl+F to toggle the Find feature of the IDE, write the word or phrase you’re searching for and press Enter or Shift+Enter to go up and down the results. As seen in the above figure, there are several options to the search namely: . | Match Case: to find a word or phrase with the same case letters. | Match Whole Word: to eliminate words or phrases that don’t contain all the letters of each word from the results. | Use Regular Expression: For an advanced search using regular expresions. | Find in Selection: to first select a piece of code and then search only within the selection. | Replace: to replace each search result with the word or phrase in the Replace field. | Replace All: to replace all of the search result with the word or phrase in the Replace field, all in one click. | . tip: To search multiple files at once press Ctrl+Shift+F. ",
    "url": "/device-development/oniro-ide/code-editing.html#find--replace",
    
    "relUrl": "/device-development/oniro-ide/code-editing.html#find--replace"
  },"22": {
    "doc": "Code Editing",
    "title": "Code Editing",
    "content": " ",
    "url": "/device-development/oniro-ide/code-editing.html",
    
    "relUrl": "/device-development/oniro-ide/code-editing.html"
  },"23": {
    "doc": "Code Navigation",
    "title": "Go to Definition",
    "content": "The “Go to Definition” feature is a code navigation tool that allows you to quickly navigate to the definition of a particular symbol in your codebase. This feature is commonly used to explore the implementation or declaration of functions, classes, variables, methods, and other code entities. You can do this by Ctrl+Click as with other IDEs or Ctrl+F11. ",
    "url": "/device-development/oniro-ide/code-navigation.html#go-to-definition",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#go-to-definition"
  },"24": {
    "doc": "Code Navigation",
    "title": "Go to Type Definition",
    "content": "This feature specifically deals with navigating to the type definition of a symbol. It is useful in statically-typed languages where you might want to see the type information associated with a variable or entity. ",
    "url": "/device-development/oniro-ide/code-navigation.html#go-to-type-definition",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#go-to-type-definition"
  },"25": {
    "doc": "Code Navigation",
    "title": "Go to Symbol",
    "content": "This allows you to quickly navigate to symbols (ie. variables, functions, classes..etc) within your file. ",
    "url": "/device-development/oniro-ide/code-navigation.html#go-to-symbol",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#go-to-symbol"
  },"26": {
    "doc": "Code Navigation",
    "title": "Go to Implementations",
    "content": "The “Go to Implementations” feature allows you to quickly jump to the implementations of a particular function, method, or interface in your codebase. This feature is particularly useful in languages that support interfaces, classes, or methods with multiple implementations. tip: If you want to see all the places where a particular method or function is implemented, “Find All Implementations” is useful for a more comprehensive overview. ",
    "url": "/device-development/oniro-ide/code-navigation.html#go-to-implementations",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#go-to-implementations"
  },"27": {
    "doc": "Code Navigation",
    "title": "Find All References",
    "content": "This is a code analysis tool that allows you to locate all occurrences or references to a particular symbol (variable, function, method, class, etc.) within your codebase. Its purpose is to provide developers with a comprehensive overview of where a specific symbol is used throughout their project. ",
    "url": "/device-development/oniro-ide/code-navigation.html#find-all-references",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#find-all-references"
  },"28": {
    "doc": "Code Navigation",
    "title": "Peek",
    "content": "This is a special feature that allows developers to quickly view the definition or implementation of a symbol inline without navigating away from the current code file to avoid context switching. You can navigate between different references in the peeked editor and make quick edits right there. ",
    "url": "/device-development/oniro-ide/code-navigation.html#peek",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html#peek"
  },"29": {
    "doc": "Code Navigation",
    "title": "Code Navigation",
    "content": "A dynamic combination of programming languages’ services and quick text editing gives Oniro IDE its power. In this topic we will give an overview of a few code navigation features which can be explored when you right click on a symbol (variable, function, method, class, etc.). ",
    "url": "/device-development/oniro-ide/code-navigation.html",
    
    "relUrl": "/device-development/oniro-ide/code-navigation.html"
  },"30": {
    "doc": "Common Issues and Solutions",
    "title": "Common Issues and Solutions",
    "content": " ",
    "url": "/application-development/environment-setup-config/common-issue.html",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html"
  },"31": {
    "doc": "Common Issues and Solutions",
    "title": "Installation Failure After Project Creation",
    "content": "There are a bunch of solutions on the forum but I simply tried switching the intranet to Internet. ",
    "url": "/application-development/environment-setup-config/common-issue.html#installation-failure-after-project-creation",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#installation-failure-after-project-creation"
  },"32": {
    "doc": "Common Issues and Solutions",
    "title": "Cannot find the emulator of a phone device",
    "content": "entry&gt;src&gt;main&gt;module.json5 is the configuration file for the module, check deviceType, add ‘phone’ if the it is missing. ",
    "url": "/application-development/environment-setup-config/common-issue.html#cannot-find-the-emulator-of-a-phone-device",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#cannot-find-the-emulator-of-a-phone-device"
  },"33": {
    "doc": "Common Issues and Solutions",
    "title": "Unable to find BMS Service when running on Emulator",
    "content": "Just wait for an extended period, or try clearing data of this device or creating a new device. ",
    "url": "/application-development/environment-setup-config/common-issue.html#unable-to-find-bms-service-when-running-on-emulator",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#unable-to-find-bms-service-when-running-on-emulator"
  },"34": {
    "doc": "Common Issues and Solutions",
    "title": "Unstable USB connection, dev board not detected by IDE",
    "content": "solution worked for me: . Change USB Power Management Settings . | Search for and open Device Manager. | Click to expand Universal Serial Bus Controllers. | Right-click on USB Root Hub and select Properties. | Uncheck Power Management and click OK. | . ",
    "url": "/application-development/environment-setup-config/common-issue.html#unstable-usb-connection-dev-board-not-detected-by-ide",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#unstable-usb-connection-dev-board-not-detected-by-ide"
  },"35": {
    "doc": "Common Issues and Solutions",
    "title": "compileSdkVersion and releaseType of the app do not match the apiVersion and releaseType on the device",
    "content": "Reason: The compiled SDK version is higher than the actual device. Solution: Step 1: Modify build_profile.json5 under entry and set apiType to faMode. Step 2: Modify build_profile.json5 under the project, change the compiled version to a lower version. Run again, and the problem will be resolved. ",
    "url": "/application-development/environment-setup-config/common-issue.html#compilesdkversion-and-releasetype-of-the-app-do-not-match-the-apiversion-and-releasetype-on-the-device",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#compilesdkversion-and-releasetype-of-the-app-do-not-match-the-apiversion-and-releasetype-on-the-device"
  },"36": {
    "doc": "Common Issues and Solutions",
    "title": "Install Failed",
    "content": "Have the device connected and detected by IDE, click on “run”, the IDE gives the error messages: “Install Failed : failed to install bundle. code: 9568289, error: install failed due to grant request permissions failed.” . It should be a permission issue, and now we need to identify the permissions causing the problem. This documentation lists all permissions and their levels in OpenHarmony. There are three types of permissions used in OpenHarmony for requests, ordered from low to high: normal, system_basic, system_core. If the permission level is set to “availableLevel”: “system_basic”, then you need to configure the acls field in the UnsignedReleasedProfileTemplate.json file and include the required high-level permissions in acls. The specific steps are as follows: . set the”profile” with p7b file generated from java -c commands in build-profile.json5 . ",
    "url": "/application-development/environment-setup-config/common-issue.html#install-failed",
    
    "relUrl": "/application-development/environment-setup-config/common-issue.html#install-failed"
  },"37": {
    "doc": "Create an Eclipse Oniro app using OpenHarmony Template",
    "title": "Create an Eclipse Oniro app using OpenHarmony Template",
    "content": "To create a project in DevEco Studio: . | Double-click the DevEco Studio icon to begin. | . | In welcome page click Create Project. | . The Create Project window opens with template market provided by DevEco Studio. In DevEco Studio, a project template serves as a blueprint for building specific types of apps. It defines the project structure and essential files, providing starter code to help you get started quickly. | Make sure the Application tab is selected on the left bar, then choose [OpenHarmony]Empty Ability as project template and click Next. | . | Configure your project with following information: | . | The Project name field is used to enter the name of your project. | The Bundle name field represents the package name, which also serves as the default application ID. Keep it as default to maintain the file organization. | The Save location field specifies where all project files are stored, you can leave it as default. | The Compile SDK specifies the API version used for compilation. By default, API 11 is selected in our case, which also sets ArkTS as the development language. | Select Stage for Model and keep the default values for all other parameters. | . Note: If you plan to use JavaScript, select API 8 instead. This will provide a language option where you can choose JS. | Click Finish and wait for the project creation. | . | Click Previewer on the right sidebar of DevEco Studio to view both the code and design simultaneously. | . | Project View(Part 1): Displays all files and folders in your project. | Code View(Part 2): The workspace for editing code. | Design View(Part 3): Allows you to preview your app’s design. | . ",
    "url": "/application-development/create-first-eclipse-oniro-app/create-template.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/create-template.html"
  },"38": {
    "doc": "Developer Account",
    "title": "Developer Account",
    "content": "Note: For application development, a developer account is not necessary. Introduction of Register and Identify Verification: HUAWEI ID Registration and Verification | HUAWEI Developers . In simple terms, anyone can register for an individual developer account, whether they choose to verify their identity or not. However, it’s said that certain permissions require an identity verification with the identity document. According to information from the Huawei developer forum, verified developers gain access to more development resources, training materials, and market promotion. Moreover, only verified developers are allowed to publish applications. Enterprise developers receive a broader range of services compared to individual developers. Here’s a breakdown: . | Individual Developers: App Market, Themes, Product Management, Account, PUSH, New Game Pre-order, Interactive Comments, Social, HUAWEI HiAI, Watch App Market, etc. | Enterprise Developers: App Market, Themes, Initial Release, Payment, Game Packages, App Market Promotion, Product Management, Games, Account, PUSH, New Game Pre-order, Interactive Comments, Social, HUAWEI HiAI, Watch App Market, Sports &amp; Health, Cloud Testing, Smart Home, etc. | . ",
    "url": "/application-development/environment-setup-config/developer-account.html",
    
    "relUrl": "/application-development/environment-setup-config/developer-account.html"
  },"39": {
    "doc": "Environment Configuration",
    "title": "Environment Configuration",
    "content": "Run DevEco Studio for the first time, configuation setting pages will appear. Select Do not import settings . On Basic Setup page, select install for Node.js and Ohpm. Click Next to proceed to the SDK configuration page, and then set the SDK path to an appropriate location. Accept the License Agreement Check the summary information and go next Environment configuration is finished. Note: If you want to run application for OpenHarmony, you need to install revelent APIs as well. You can download public SDK from DevEco Studio-&gt;Tool-&gt;SDK Manager-&gt;OpenHarmony, select API and click Apply to download. (If you downloaded DevEco Studio version is 4.1, choose API Version 11 for development.) . ",
    "url": "/application-development/environment-setup-config/env-config.html",
    
    "relUrl": "/application-development/environment-setup-config/env-config.html"
  },"40": {
    "doc": "Find project files",
    "title": "Find project files",
    "content": ". | In DevEco Studio, take a look at the Project tab. The Project tab shows the actual file directory structure of the project as well as all project items and their dependencies (including SDKs and libraries) | . | Select Project Files from the drop-down menu. You can browse all the files in the project content root directory, but does not display external libraries and frameworks. | . | If necessary, select Open Files to quickly jump between recently viewed files. | . | Select Ohos from the drop-down menu. This optimized view clearly presents essential files required for development, making it easier for developers to quickly locate core code and resources related to application development. | . For our application development, the Ohos view is usually the best choice, we will use Ohos tab in this course. ",
    "url": "/application-development/create-first-eclipse-oniro-app/find-project-files.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/find-project-files.html"
  },"41": {
    "doc": "Full SDK & Public SDK",
    "title": "Full SDK &amp; Public SDK",
    "content": "There are two types of SDKs: . | Public-SDK: A toolkit provided for application development. It is available to download with DevEco Studio and does not include high-permission APIs required for system applications. | Full-SDK: A toolkit provided for OEM manufacturers to develop applications. It cannot be downloaded with DevEco Studio and includes high-permission APIs required for system applications. | . ",
    "url": "/application-development/environment-setup-config/full-public-sdk.html#full-sdk--public-sdk",
    
    "relUrl": "/application-development/environment-setup-config/full-public-sdk.html#full-sdk--public-sdk"
  },"42": {
    "doc": "Full SDK & Public SDK",
    "title": "How to get the Full SDK?",
    "content": "Approach 1: From CICD pipeline (Recommended) . Get the Full SDK . | Obtain the latest OpenHarmony SDK from the OpenHarmony daily build pipline [Daily Build | OpenHarmony CI](https://ci.openharmony.cn/workbench/cicd/dailybuild/dailylist). The daily build pipeline builds system images, SDKs, etc. | . Use conditional filtering, such as selecting the project as openharmony, selecting the target branch OpenHarmony-4.1-Release, selecting a date from the previous month, or manually choosing a range. In the daily build or rolling build, find ohos-sdk-full_4.1-Release, and click on the download link to choose and download the full package, which includes Full-SDK for Windows and Linux. (If daily build SDK is not compatible with your version of DevEco Studio, try to use rolling build SDK instead) . | . | pipeline | description | remark | . | ohos-sdk-public | The public SDK is available for Linux and Windows platforms | It is provided for application developers and does not include system interfaces that require system permissions | . | mac-sdk-public | The public SDK for macOS is available | It is provided for application developers and does not include system interfaces that require system permissions | . | ohos-sdk-full | Applicable to Linux and Windows platforms. If you want to use system APIs, you need to use this SDK. | Available to OEMs, including system interfaces that require access to the system | . | mac-sdk-full | Full SDK for macOS. If you want to use system APIs, you need to use this SDK. | Available to OEMs, including system interfaces that require access to the system | . | Make sure that the downloaded SDK is the full SDK. Check whether the downloaded file name contains “full-SDK.” Check if the API includes system APIs such as @ohos.app.ability.abilityManager.d.ts, @ohos.app.form.formInfo.d.ts, and @ohos.bluetooth.d.ts | . Replace the Full SDK . Take the replacement of the full SDK of DevEco Studio 4.1, API 11 on Windows OS as an example. | Backup and remove the local SDK: Make sure to select OpenHarmony then navigate to the directory where the original SDK is installed. | . Copy the entire SDK directory (e.g., 11) to another location on your system where you want to keep the backup. Now you can remove the original SDK from its directory. | The SDK you have acquired needs to be recognized by DevEco Studio in order to be used. For example, with the daily build SDK: version-Master_Version-OpenHarmony_4.1.7.7-20240830_034700-ohos-sdk-public_4.1-release.tar.gz, the compressed file has the following directory structure. You can see that it contains SDK files for both Linux and Windows platforms. Each platform’s SDK includes directories such as ets, js, native, previewer, and toolchains. └─version-Master_Version-OpenHarmony_4.1.7.7-20240830_034700-ohos-sdk-public_4.1-Release │ manifest\\_tag.xml │ └─ohos-sdk ├─linux │ ets-linux-x64-4.1.7.8-Release │ js-linux-x64-4.1.7.8-Release │ native-linux-x64-4.1.7.8-Release │ previewer-linux-x64-4.1.7.8-Release │ toolchains-linux-x64-4.1.7.8-Release │ └─windows ets-windows-x64-4.1.7.8-Release js-windows-x64-4.1.7.8-Release native-windows-x64-4.1.7.8-Release previewer-windows-x64-4.1.7.8-Release toolchains-windows-x64-4.1.7.8-Release . | Create a new directory with the API version 11 as the file name in dir path: xxx\\Sdk\\ , unzip the compressed files into this directory to form a structure below: . | Verify in the IDE: Full API will be loaded in IDE and you can now rebuild the project. Full SDK replacement tutorial finished. | . Approach 2: From Compiled Source Files . The Full-SDK is not available directly. It can be compiled from the source code of OpenHarmony and manually replaced in DevEco Studio. The method of replacing the SDK is the same as the one mentioned in Approach 1. You can find the guide of compilation of source code here: How to compile Full SDK . Please use translation tools if needed. ",
    "url": "/application-development/environment-setup-config/full-public-sdk.html#how-to-get-the-full-sdk",
    
    "relUrl": "/application-development/environment-setup-config/full-public-sdk.html#how-to-get-the-full-sdk"
  },"43": {
    "doc": "Full SDK & Public SDK",
    "title": "Full SDK & Public SDK",
    "content": " ",
    "url": "/application-development/environment-setup-config/full-public-sdk.html",
    
    "relUrl": "/application-development/environment-setup-config/full-public-sdk.html"
  },"44": {
    "doc": "Getting Started",
    "title": "Installation",
    "content": "Please make sure that your system follows the Theia development prerequisites. Building . The IDE can be built &amp; run in your browser, or as a packaged desktop application using Electron. You can build both browser and electron application by running the following script: . yarn yarn compile yarn download:plugins . Running . To start the browser application you need to run: . yarn browser start . And similarly for the electron application: . yarn electron start . Watching . To continuously compile the written TypeScript code, run the respective commands for your runtime: . yarn browser watch . Or . yarn electron watch . Running in Docker container . Install docker. To create oniro-ide docker image: . docker build -t oniro-ide . To start oniro-ide-container container: . docker run -dp 3000:3000 --name oniro-ide-container oniro-ide . When you open the browser at http://localhost:3000/ you will see the browser version of the IDE. ",
    "url": "/device-development/oniro-ide/getting-started.html#installation",
    
    "relUrl": "/device-development/oniro-ide/getting-started.html#installation"
  },"45": {
    "doc": "Getting Started",
    "title": "Creating and Running a Project",
    "content": "To create a new project navigate to Project from the menu tab and click New Project. From the pop-up window select the folder where you want to save your project and give your project a name. Finally select the hardware chip of your choice, click Next and Finish. This creates a new project workspace for your development. To open your project, navigate to File -&gt; Open... from the menu tab, navigate to your project’s location, and click Open. This will open your project as you can see down in the Explorer. From here on out you can add files/folders using the Explorer pane or use tools such as npm package manager to help you create projects. Note: So far you can develop projects in the IDE in a plethora of languages. However, building and running project is still under construction. ",
    "url": "/device-development/oniro-ide/getting-started.html#creating-and-running-a-project",
    
    "relUrl": "/device-development/oniro-ide/getting-started.html#creating-and-running-a-project"
  },"46": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/device-development/oniro-ide/getting-started.html",
    
    "relUrl": "/device-development/oniro-ide/getting-started.html"
  },"47": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "HiHope HH-SCDAYU200 Development Kit",
    "content": "Text from here . ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#hihope-hh-scdayu200-development-kit",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#hihope-hh-scdayu200-development-kit"
  },"48": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "Introduction",
    "content": "Based on the Rockchip RK3568, this development kit integrates advanced features such as a dual-core architecture GPU and a high-performance NPU. Complemented by an onboard quad-core 64-bit Cortex-A55 processor which has a frequency of up to 2.0GHz, it ensures robust performance. The rich set of peripherals ranges from Bluetooth and Wi-Fi to audio, video, camera and a variety of Bosch Sensortec sensors. The expansion board offers rich expansion interfaces, and supports a variety of video input and output interfaces suited for applications with rich user interface requirements. It is also equipped with dual Gigabit adaptive RJ45 Ethernet ports, which can meet the needs of NVR, industrial gateway and other multi-network port products. ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#introduction",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#introduction"
  },"49": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "Specification",
    "content": "Development Board Specification . | Category | Specification | . | SOC Model | Rockchip RK3568 | . | CPU Architecture | Quad-core Cortex-A55 up to 2.0GHz | . | GPU | Mali-G52 GPU | . | Supported APIs | OpenGL ES 1.1/2.0/3.2, OpenCL 2.0, Vulkan 1.1 | . | Video Decoding | Supports 4K at 60fps H.265/H.264/VP9 video decoding | . | Video Encoding | Supports 1080P at 100fps H.265/H.264 video encoding | . | NPU Performance | 0.8TOPs | . | Supported Operations | INT8, INT16, FP16 operations | . | RAM | 2/4GB LPDDR4/LPDDR4x, running at 1600MHz | . | Storage | 16/32 GB | . | Power Input | DC 12V/2A | . | Operating Systems | OpenHarmony | . | Connector Type | SODIMM 314P (MXM 3.0) | . Expansion Board Specification . | Category | Specification | . | HDMI | 1x HDMI2.0(Type-A), supports 4K at 60fps output | . | MIPI | 2x MIPI interface, supports 1920x1080 at 60fps output | . | eDP Interface | 1x eDP interface, supports 2K at 60fps output | . | I2S/TDM/PDM | 1x 8 channel I2S/TDM/PDM | . | Ethernet | 2x GMAC(10/100/1000M) | . | SDIO | Supports Wi-Fi 5G/2.5G, BT4.2 | . | Camera Interface | MIPI-CSI2, 1x4-lane/2x2-lane at 2.5Gbps/lane | . | USB | 1x USB2.0 Host, Type-A; 1x USB3.0 Host, Type-A; 1x USB3.0 OTG | . | M.2 Interface | 4G LTE Module | . | PCIe | 1x 2 Lanes PCIe3.0 Connector (RC Mode) | . | SATA | 1x SATA3.0 Connector | . | SDMMC | 1x Micro SD Card3.0 | . | Buttons | 1x Vol+/Recovery; 1x Reset; 1x Power; 1x Vol-; 1x Mute | . | RTC | 1x RTC | . | Infrared | 1x IR | . | LEDs | 3x LED | . | Sensors | Bosch Sensortec BMA456, BMI270 and BMP581 | . | Fan | 1x Fan | . ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#specification",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#specification"
  },"50": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "Building",
    "content": "To build Eclipse Oniro for this board the normal quick build procedure has to be used to fetch the needed source code and environment. During the build step, inside the Docker instance, the target device for the build has to be set to rk3568./build.sh --product-name rk3568 --ccache . ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#building",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#building"
  },"51": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "Flashing",
    "content": "To begin, connect the board to your computer as outlined in the HiHope DAYU200 documentation. Use the USB-C and mini-USB cables included in the kit to connect to the USB 3.0 OTG port and the mini-USB DEBUG port, respectively. Power on the device by attaching the power cable. Upon successful connection, your serial console should display output similar to: . Bus 002 Device 009: ID 2207:5000 Fuzhou Rockchip Electronics Company \"HDC Device\" ... Bus 001 Device 069: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC . Download the flash.py flashing tool from Gitee using the following commands: . git clone https://gitee.com/hihope_iot/docs.git hihope_iot_docs mkdir flash &amp;&amp; cp -r hihope_iot_docs/HiHope_DAYU200/烧写工具及指南/linux/* flash/ chmod +x flash/flash.py flash/bin/flash.x86_64 . To ensure proper device recognition, install the udev rule: . sudo cp flash/etc/udev/rules.d/85-rk3568.rules /etc/udev/rules.d/85-rk3568.rules . Then, either reload udev rules or reboot your system: . udevadm control --reload-rules . After this setup, running flash/flash.py -q should produce the following output, indicating readiness: . maskrom . To enable programming mode on the device, perform the following steps: . | Press and hold VOL/RECOVERY then RESET buttons. | Release RESET button. | . Confirm the mode by running lsusb, which should show: ... Bus 001 Device 070: ID 2207:350a Fuzhou Rockchip Electronics Company USB download gadget ... $ flash/flash.py -q loader . Once the above steps are completed successfully, you can proceed to flash the board: . flash/flash.py -a -i ./out/rk3568/packages/phone/images . Connecting to serial console . To read the serial output, ensure the board is correctly connected and powered on. The default baud rate for the HH-SCDAYU200 board is 1500000. You can use minicom or a similar serial terminal: . minicom -D /dev/ttyUSB0 -b 1500000 . ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#flashing",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#flashing"
  },"52": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "Reference",
    "content": "The original specification and some hardware description comes form the original (Chinese) HiHope documentation published on Gitee. More details and purchase options can be found at the manufactures product page. ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#reference",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html#reference"
  },"53": {
    "doc": "HiHope HH-SCDAYU200",
    "title": "HiHope HH-SCDAYU200",
    "content": " ",
    "url": "/device-development/supported-device/boards/hihope_hh-scdayu200.html",
    
    "relUrl": "/device-development/supported-device/boards/hihope_hh-scdayu200.html"
  },"54": {
    "doc": "IDE Installation",
    "title": "IDE Installation",
    "content": "We are using DevEco Studio as the IDE . ",
    "url": "/application-development/environment-setup-config/ide-installation.html",
    
    "relUrl": "/application-development/environment-setup-config/ide-installation.html"
  },"55": {
    "doc": "IDE Installation",
    "title": "Get Package",
    "content": "You can install DevEco Studio from here (Current download version is DevEco Studio 4.1) or you can visit the OpenHarmony release notes If the EN version not available, try translating the page to English . Windows(64-bit) . SHA256：c46be4f3cfde27af1806cfc9860d9c366e66a20e31e15180cf3a90ab05464650 . Mac(X86) . SHA256：15d6136959b715e4bb2160c41d405b889820ea26ceadbb416509a43e59ed7f09 . Mac(ARM) . SHA256：ac04ca7c2344ec8f27531d5a59261ff037deed2c5a3d42ef88e6f90f4ed45484 . ",
    "url": "/application-development/environment-setup-config/ide-installation.html#get-package",
    
    "relUrl": "/application-development/environment-setup-config/ide-installation.html#get-package"
  },"56": {
    "doc": "IDE Installation",
    "title": "Step by Step Installation",
    "content": "After the download completes, extract the downloaded package and run deveco-studio-xxxx.exe. Keep clicking next until Choose Install Location procedure. Specify desired installtion path by clicking Browse... if necessary and click next. Note: Ensure that you delete all files from the previous installation path before proceeding if it’s not your first installation. In Installation Options procedure, select Create Desktop Shortcut . In Choose Start Menu Folder procedure, keep default settings and click install. The installation is finished. ",
    "url": "/application-development/environment-setup-config/ide-installation.html#step-by-step-installation",
    
    "relUrl": "/application-development/environment-setup-config/ide-installation.html#step-by-step-installation"
  },"57": {
    "doc": "IDE Installation",
    "title": "Environment Configuration",
    "content": "Run DevEco Studio for the first time, configuation setting pages will appear. Select Do not import settings . On Basic Setup page, select install for Node.js and Ohpm. Click Next to proceed to the SDK configuration page, and then set the SDK path to an appropriate location. Accept the License Agreement Check the summary information and go next Environment configuration is finished. Note: If you want to run application for OpenHarmony, you need to install revelent APIs as well. You can download public SDK from DevEco Studio-&gt;Tool-&gt;SDK Manager-&gt;OpenHarmony, select API and click Apply to download. (If you downloaded DevEco Studio version is 4.1, choose API Version 11 for development.) . ",
    "url": "/application-development/environment-setup-config/ide-installation.html#environment-configuration",
    
    "relUrl": "/application-development/environment-setup-config/ide-installation.html#environment-configuration"
  },"58": {
    "doc": "Policies and Compliance",
    "title": "Policies and Compliance",
    "content": " ",
    "url": "/policies-and-compliance/#policies-and-compliance",
    
    "relUrl": "/policies-and-compliance/#policies-and-compliance"
  },"59": {
    "doc": "Policies and Compliance",
    "title": "Policies and Compliance",
    "content": "to do . ",
    "url": "/policies-and-compliance/",
    
    "relUrl": "/policies-and-compliance/"
  },"60": {
    "doc": "Create Your First Eclipse Oniro Application",
    "title": "Before you begin",
    "content": "Make sure you have gone through the environment setup guide. In this tutorial, you will create your first Eclipse Oniro application with OpenHarmony template provided by DevEco Studio. Prerequisites . | Current available version of DevEco Studio installed on your system | . What you will learn . | Set up DevEco Studio: Installed and configured the necessary environment for application development. | Created a new project: Used the [openHarmony]Empty Ability template to initialize a project. | Explored the project structure: Navigated different views like Ohos and Project Files to locate and manage files. | Used the Previewer: Learned how to preview UI updates in real time, switch devices, rotate screens, and inspect components. | Built UI components: Added Text and Button components to display messages and handle user interactions. | Implemented page navigation: Used the router module to enable redirection between pages with transition effects. | Deployed on a real device: Installed HDC, configured device settings, and ran the application on a physical HiHope HH-SCDAYU200 Development Kit. | . What you will build . | An application with two pages that support mutual navigation. | . ",
    "url": "/application-development/create-first-eclipse-oniro-app/#before-you-begin",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/#before-you-begin"
  },"61": {
    "doc": "Create Your First Eclipse Oniro Application",
    "title": "Create Your First Eclipse Oniro Application",
    "content": " ",
    "url": "/application-development/create-first-eclipse-oniro-app/",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/"
  },"62": {
    "doc": "Resource Categories and Access",
    "title": "Resource Categories",
    "content": "Resource files used during application development must be stored in specified directories for management. There are two types of resource directories, namely, resource directories and resource group directories. The resource directories are the base, qualifiers, rawfile, and resfile directories. The resource group directories are the element, media, and profile directories. NOTE . The common resource files used across projects in the stage model are stored in the resources directory under AppScope. Example of the resources directory: . resources |---base |---element | |---string.json |---media | |---icon.png |---profile | |---test_profile.json |---en_US // Default directory. When the device language is en-us, resources in this directory are preferentially matched. |---element | |---string.json |---media | |---icon.png |---profile | |---test_profile.json |---zh_CN // Default directory. When the device language is zh-cn, resources in this directory are preferentially matched. |---element | |---string.json |---media | |---icon.png |---profile | |---test_profile.json |---en_GB-vertical-car-mdpi // Example of a qualifiers directory, which needs to be created on your own. |---element | |---string.json |---media | |---icon.png |---profile | |---test_profile.json |---rawfile // Other types of files are saved as raw files and will not be integrated into the resources.index file. You can customize the file name as needed. |---resfile // Other types of files are saved as raw files and will not be integrated into the resources.index file. You can customize the file name as needed. Resource Directories . base Directory . The base directory is provided by default. Under this directory, the element subdirectory stores basic elements such as strings, colors, and boolean values, and the media and profile subdirectories store resource files such as media, animations, and layouts. Resource files in the subdirectories are compiled into binary files, and each resource file is assigned an ID. Resource files in the subdirectory are referenced based on the resource type and resource name. Qualifiers Directory . en_US and zh_CN are two default qualifiers directories. You need to create other qualifiers directories on your own. Under this directory, the subdirectories store basic elements such as strings, colors, and boolean values, as well as resource files such as media, animations, and layouts.Resource files in the subdirectories are compiled into binary files, and each resource file is assigned an ID. Resource files in the subdirectories are referenced based on the resource type and resource name. rawfile Directory . You can create multiple levels of subdirectories with custom names to store various resource files.Resource files in the subdirectories are directly packed into the application without being compiled, and no IDs will be assigned to the resource files. The subdirectories are referenced based on the specified file path and file name. resfile Directory . You can create multiple levels of subdirectories with custom names to store various resource files.Resource files in the subdirectories are directly packed into the application without being compiled, and no IDs will be assigned to the resource files. After an application is installed, the resfile directory is decompressed to the application sandbox path. You can obtain the path through the resourceDir attribute of Context. Resource Group Directories . Resource group directories include element, media, and profile, which are used to store resources of specific types. Table 3 Resource group directories . | Directory | Description | Resource File | . | element | Element resources. Each type of data is represented by a JSON file. (Only files are supported in this directory.) The options are as follows:- boolean: boolean data- color: color data- float: floating point number ranging from -2^128 to 2^128- intarray: array of integers- integer: integer ranging from -2^31 to 2^31-1- pattern: style (for system applications only) - plural: plural form data- strarray: array of strings- string: string in the specified format.- theme: theme (for system applications only) | It is recommended that files in the element subdirectory be named the same as the following files, each of which can contain only data of the same type:- boolean.json- color.json- float.json- intarray.json- integer.json- pattern.json- plural.json- strarray.json- string.json | . | media | Indicates media resources, including non-text files such as images, audios, and videos. (Only files are supported in this directory.)Table 4 and Table 5 describe the types of images, audios, and videos. | The file name can be customized, for example, icon.png. | . | profile | Indicates a custom configuration file. (Only JSON files are supported in this directory.) | The file name can be customized, for example, test_profile.json. | . Media Resource Types . Table 4 Image resource types . | Format | File Name Extension | . | JPEG | .jpg | . | PNG | .png | . | GIF | .gif | . | SVG | .svg | . | WEBP | .webp | . | BMP | .bmp | . Table 5 Audio and video resource types . | Format | File Name Extension | . | H.264 AVC | .3gp | . | Baseline Profile (BP) | .mp4 | . Resource File Examples . The content of the color.json file is as follows: . { \"color\": [ { \"name\": \"color_hello\", \"value\": \"#ffff0000\" }, { \"name\": \"color_world\", \"value\": \"#ff0000ff\" } ] } . The content of the float.json file is as follows: . { \"float\":[ { \"name\":\"font_hello\", \"value\":\"28.0fp\" }, { \"name\":\"font_world\", \"value\":\"20.0fp\" } ] } . The content of the string.json file is as follows: . { \"string\":[ { \"name\":\"string_hello\", \"value\":\"Hello\" }, { \"name\":\"string_world\", \"value\":\"World\" }, { \"name\":\"message_arrive\", \"value\":\"We will arrive at %1$s.\" }, { \"name\":\"message_notification\", \"value\":\"Hello, %1$s!,You have %2$d new messages.\" } ] } . The content of the plural.json file is as follows: . { \"plural\":[ { \"name\":\"eat_apple\", \"value\":[ { \"quantity\":\"one\", \"value\":\"%d apple\" }, { \"quantity\":\"other\", \"value\":\"%d apples\" } ] } ] } . ",
    "url": "/application-development/resource-categories-and-access/#resource-categories",
    
    "relUrl": "/application-development/resource-categories-and-access/#resource-categories"
  },"63": {
    "doc": "Resource Categories and Access",
    "title": "Resource Access",
    "content": "HAP Resources . | Use $r or $rawfile to reference resources.To reference resources of the color, float, string, plural, media, or profile type, use the “$r(‘app.type.name’)” format, where app indicates the resource defined in the resources directory, type indicates the resource type or resource save path, and name indicates the name you assign to the resource.To reference strings with multiple placeholders in the string.json file, use the “$r(‘app.string.label’,’aaa’,’bbb’,444)” format.To reference resources in the rawfile subdirectory, use the “$rawfile(‘filename’)” format. Wherein filename indicates the relative path of a file in the rawfile subdirectory, which must contain the file name extension and cannot start with a slash (/). | . The usage is as follows: . Text('Hello') .fontColor($r('sys.color.ohos_id_color_emphasize')) .fontSize($r('sys.float.ohos_id_text_size_headline1')) .fontFamily($r('sys.string.ohos_id_text_font_family_medium')) .backgroundColor($r('sys.color.ohos_id_color_palette_aux1')) Image($r('sys.media.ohos_app_icon')) .border({ color: $r('sys.color.ohos_id_color_palette_aux1'), radius: $r('sys.float.ohos_id_corner_radius_button'), width: 2 }) .margin({ top: $r('sys.float.ohos_id_elements_margin_horizontal_m'), bottom: $r('sys.float.ohos_id_elements_margin_horizontal_l') }) .height(200) .width(300) . | Obtain a ResourceManager object through the application context, and then call resource management APIs to access different resources.For example, call getContext.resourceManager.getStringByNameSync(‘app.string.XXX’) to obtain string resources; call getContext.resourceManager.getRawFd(‘rawfilepath’) to obtain the descriptor of the HAP where the raw file is located, and then use the descriptor ({fd, offset, length}) to access the raw file. | . Cross-HAP/HSP Resources . Cross-Bundle Access (for System Applications Only) . | Call createModuleContext(bundleName, moduleName) to obtain the context of the target HAP/HSP module in another application. Obtain a ResourceManager object through the context, and then call resource management APIs to access different resources.Example: getContext.createModuleContext(bundleName, moduleName).resourceManager.getStringByNameSync(‘app.string.XXX’) | . Inter-Bundle, Cross-Module Access . | Call createModuleContext(moduleName) to obtain the context of the target HAP/HSP module in the same application. Obtain a ResourceManager object through the context, and then call resource management APIs to access different resources.Example: getContext.createModuleContext(moduleName).resourceManager.getStringByNameSync(‘app.string.XXX’). | Use $r or $rawfile to reference resources. Specifically, perform either of the following: . | Use [hsp].type.name, where hsp indicates the HSP module name, type indicates the resource type, and name indicates the resource name. The following is an example: | . Text($r('[hsp].string.test_string')) .fontSize($r('[hsp].float.font_size')) .fontColor($r('[hsp].color.font_color')) Image($rawfile('[hsp].icon.png')) . | Use variables. The following is an example: | . @Entry @Component struct Index { text: string = '[hsp].string.test_string'; fontSize: string = '[hsp].float.font_size'; fontColor: string = '[hsp].color.font_color'; image: string = '[hsp].media.string'; rawfile: string = '[hsp].icon.png'; build() { Row() { Text($r(this.text)) .fontSize($r(this.fontSize)) .fontColor($r(this.fontColor)) Image($r(this.image)) Image($rawfile(this.rawfile)) } } } . NOTE . The HSP module name must be placed in the brackets ([]). If the rawfile directory contains multiple levels of folders, the path must start from the first level, for example, $rawfile(‘[hsp].oneFile/twoFile/icon.png’). When $r or $rawfile is used for cross-HSP resource access, resource verification is not available at compile time, and you need to manually check that the target resources exist in the corresponding location. | . System Resources . Apart from custom resources, you can use system resources to develop different applications with the same visual style. For details about the system resource IDs and their values in different configurations, see Resources. During development, the usage of layered parameters is basically the same as that of qualifiers. To reference a system resource, use the “$r(‘sys.type.resource_id’)” format. Wherein: sys indicates a system resource; type indicates the resource type, which can be color, float, string, or media; resource_id indicates the resource ID. NOTE . | The use of system resources is only supported in the declarative development paradigm. | For preset applications, you are advised to use system resources. For third-party applications, you can choose to use system resources or custom application resources as required. | . Text('Hello') .fontColor($r('sys.color.ohos_id_color_emphasize')) .fontSize($r('sys.float.ohos_id_text_size_headline1')) .fontFamily($r('sys.string.ohos_id_text_font_family_medium')) .backgroundColor($r('sys.color.ohos_id_color_palette_aux1')) Image($r('sys.media.ohos_app_icon')) .border({ color: $r('sys.color.ohos_id_color_palette_aux1'), radius: $r('sys.float.ohos_id_corner_radius_button'), width: 2 }) .margin({ top: $r('sys.float.ohos_id_elements_margin_horizontal_m'), bottom: $r('sys.float.ohos_id_elements_margin_horizontal_l') }) .height(200) .width(300) . ",
    "url": "/application-development/resource-categories-and-access/#resource-access",
    
    "relUrl": "/application-development/resource-categories-and-access/#resource-access"
  },"64": {
    "doc": "Resource Categories and Access",
    "title": "Resource Matching",
    "content": "When your application needs to use a resource, the system preferentially searches the qualifiers subdirectories that match the current device state. The system searches the base subdirectory for the target resource only when the resources directory does not contain any qualifiers subdirectories that match the current device state or the target resource is not found in the qualifiers subdirectories. The rawfile directory is not searched for resources. Rules for Matching Qualifiers Subdirectories and Device Resources . | Qualifiers are matched with the device resources in the following priorities: MCC&amp;MNC &gt; locale (options: language, language_script, language_country/region, and language_script_country/region) &gt; screen orientation &gt; device type &gt; color mode &gt; screen density . | If the qualifiers subdirectories contain the MCC, MNC, language, script, screen orientation, device type, and color mode qualifiers, their values must be consistent with the current device status so that the subdirectories can be used for matching the device resources. For example, the qualifiers subdirectory zh_CN-car-ldpi cannot be used for matching the resource files labeled en_US. | . For more information about how resources are loaded in applications, see the internationalization and localization documents. Overlay Mechanism . Overlay is a resource replacement mechanism. With overlay resource packages, you enable your application GUI to adapt to different styles of various brands and products, without having to repack your application HAPs. The overlay mechanism works in dynamic and static modes. Overlay resource packages contain only resource files, resource index files, and configuration files. | Using overlay in dynamic mode | . | Place the overlay resource package in the target application installation path and install the package using hdc install. For example, for the com.example.overlay application, place the overlay resource package in data/app/el1/bundle/public/com.example.overlay/. | The application uses addResource(path) to load overlay resources and uses removeResource(path) to remove overlay resources. The path to an overlay resource consists of the application’s sandbox root directory (obtained through getContext().BundleCodeDir) and the overlay resource package name. For example, let path = getContext().bundleCodeDir + “Overlay resource package name”, such as /data/storage/el1/bundle/overlayResourcePackageName. | . | Using overlay in static mode | . The module.json5 file in the inter-application overlay resource package supports the following fields: . \"app\":{ \"bundleName\": \"com.example.myapplication.overlay\", \"vendor\" : \"example\", \"versinCode\": \"1000000\", \"versionName\": \"1.0.0.1\", \"icon\": \"$media:app_icon\", \"label\": \"$string:app_name\", }, \"module\":{ \"name\": \"entry_overlay_module_name\", \"type\": \"shared\", \"description\": \"$string:entry_overlay_desc\", \"deviceTypes\": [ \"default\", \"tablet\", ], \"deliverywithInstall\": true, \"targetModuleName\": \"entry_module_name\", \"targetPriority\": 1, } } . The module.json5 file in the cross-application overlay resource package supports the following fields, which are available for system applications only: . \"app\":{ \"bundleName\": \"com.example.myapplication.overlay\", \"vendor\" : \"example\", \"versinCode\": \"1000000\", \"versionName\": \"1.0.0.1\", \"icon\": \"$media:app_icon\", \"label\": \"$string:app_name\", \"targetBundleName\": \"com.example.myapplication\", \"targetPariority\": 1, }, \"module\":{ \"name\": \"entry_overlay_module_name\", \"type\": \"shared\", \"description\": \"$string:entry_overlay_desc\", \"deviceTypes\": [ \"default\", \"tablet\", ], \"deliverywithInstall\": true, \"targetModuleName\": \"entry_module_name\", \"targetPriority\": 1, } } . NOTE . | targetBundleName: name of the target application to apply the overlay feature. The value is a string. | targetModuleName: name of the target module to apply the overlay feature. The value is a string. | targetPriority: overlay priority. The value is an integer. | Other fields such as Ability, ExtensionAbility, and Permission are not supported. | The overlay feature does not support JSON images. | . If the module.json5 file of a module contains the targetModuleName and targetPriority fields during project creation on DevEco Studio, the module is identified as a module with the overlay feature in the installation phase. Modules with the overlay feature generally provide an overlay resource file for other modules on the device, so that the module specified by targetModuleName can display different colors, labels, themes, and the like by using the overlay resource file in a running phase. The overlay feature is enabled by default. For details about how to enable and disable this feature, see @ohos.bundle.overlay (overlay). ",
    "url": "/application-development/resource-categories-and-access/#resource-matching",
    
    "relUrl": "/application-development/resource-categories-and-access/#resource-matching"
  },"65": {
    "doc": "Resource Categories and Access",
    "title": "Resource Categories and Access",
    "content": "Text source from here . During application development, you may need to use different resources, such as colors, fonts, spacing, and images, based on the device or configuration. Depending on the resource type, you can achieve this using the following methods: . | Application resources: configure device- or configuration-specific resources in the resource files. | System resources: Obtain the ID and configuration-specific values of colors, fonts, or other resources in Resources; obtain system icons in HarmonyOS Symbol. | . ",
    "url": "/application-development/resource-categories-and-access/",
    
    "relUrl": "/application-development/resource-categories-and-access/"
  },"66": {
    "doc": "Basic Concepts",
    "title": "Basic Concepts",
    "content": "todo: Add some words . ",
    "url": "/application-development/basic-concepts/",
    
    "relUrl": "/application-development/basic-concepts/"
  },"67": {
    "doc": "Environment Setup Guide",
    "title": "Environment Setup Guide",
    "content": "Text from here . This guide aims to help developer set up their own development environment. ",
    "url": "/application-development/environment-setup-config/",
    
    "relUrl": "/application-development/environment-setup-config/"
  },"68": {
    "doc": "Application Development",
    "title": "Development Overview",
    "content": "Welcome to Oniro Application Development Development Environment Learning Path . ",
    "url": "/application-development/#development-overview",
    
    "relUrl": "/application-development/#development-overview"
  },"69": {
    "doc": "Application Development",
    "title": "Welcome to Oniro Application Development",
    "content": "Oniro is a modern, flexible operating system designed for diverse device scenarios. This documentation is your starting point to quickly learn how to start your Oniro application development. It provides clear, concise tutorials and practical examples, so you can get started rapidly without needing to understand all underlying complexities right away. By following this documentation, you’ll learned: . | Set up a straightforward development environment. | Build and run your first simple Oniro application. | Gradually learn essential concepts needed to further your development journey. | . ",
    "url": "/application-development/#welcome-to-oniro-application-development",
    
    "relUrl": "/application-development/#welcome-to-oniro-application-development"
  },"70": {
    "doc": "Application Development",
    "title": "Development Environment",
    "content": "To start developing OpenHarmony applications, we first need to set up the development environment by installing DevEco Studio. To set up your development environment, please refer to Environment Setup Guide. ",
    "url": "/application-development/#development-environment",
    
    "relUrl": "/application-development/#development-environment"
  },"71": {
    "doc": "Application Development",
    "title": "Learning Path",
    "content": "To be added To facilitate your application development, we provide development guidelines for reference. ",
    "url": "/application-development/#learning-path",
    
    "relUrl": "/application-development/#learning-path"
  },"72": {
    "doc": "Application Development",
    "title": "Application Development",
    "content": "The text base on here . ",
    "url": "/application-development/",
    
    "relUrl": "/application-development/"
  },"73": {
    "doc": "boards",
    "title": "boards",
    "content": "Text from here . This section delves into the specifics of Eclipse Oniro’s supported developer boards. ‘Supported’ here means being in active use by its developers and being part of the CI/CD pipeline that guards the development processes. Currently this only cover the HiHope SCDAYU200 development board. Given Eclipse Oniro is based on OpenHarmony, a way broader set of hardware support is available in the codebase. The only reason the other devices are not listedhere, is the missing active use and CI/CD testing. ",
    "url": "/device-development/supported-device/boards/",
    
    "relUrl": "/device-development/supported-device/boards/"
  },"74": {
    "doc": "virtual machine",
    "title": "virtual machine",
    "content": "virtual machine . ",
    "url": "/device-development/supported-device/virtual-machine/",
    
    "relUrl": "/device-development/supported-device/virtual-machine/"
  },"75": {
    "doc": "Supported Devices",
    "title": "Supported Devices",
    "content": "Supported Devices . ",
    "url": "/device-development/supported-device/",
    
    "relUrl": "/device-development/supported-device/"
  },"76": {
    "doc": "Oniro IDE",
    "title": "Oniro IDE",
    "content": "Oniro IDE . ",
    "url": "/device-development/oniro-ide/",
    
    "relUrl": "/device-development/oniro-ide/"
  },"77": {
    "doc": "Device Development",
    "title": "Device Development",
    "content": " ",
    "url": "/device-development/#device-development",
    
    "relUrl": "/device-development/#device-development"
  },"78": {
    "doc": "Device Development",
    "title": "Device Development",
    "content": "to do . ",
    "url": "/device-development/",
    
    "relUrl": "/device-development/"
  },"79": {
    "doc": "Community",
    "title": "Community",
    "content": ". | Public developers mailing lists | Public working group’s mailing lists | Chat | Social media: LinkedIn, X, Mastodon | . ",
    "url": "/community/",
    
    "relUrl": "/community/"
  },"80": {
    "doc": "Eclipse Oniro Project",
    "title": "Welcome to Oniro Project documentation!",
    "content": "Oniro™ is a registered trademark of Eclipse Foundation. In 2023, the Oniro project underwent a significant transition. For those seeking information on the project’s previous developments, including the state of the art IP compliance toolchain, please consult our legacy documentation. ",
    "url": "/#welcome-to-oniro-project-documentation",
    
    "relUrl": "/#welcome-to-oniro-project-documentation"
  },"81": {
    "doc": "Eclipse Oniro Project",
    "title": "About Oniro",
    "content": "Oniro is an open-source, vendor-neutral Operating System (OS) managed by the Eclipse Foundation. It is built upon the foundational layers of OpenHarmony, an open-source project incubated and operated by the OpenAtom Foundation. OpenHarmony is known for its distributed OS features that cater to a wide range of smart devices, regardless of their size. Oniro extends OpenHarmony code base with add-ons for the European and Global markets, such as ReactNative support, Eclipse Theia based IDE, Servo web engine, and more that are coming. ",
    "url": "/#about-oniro",
    
    "relUrl": "/#about-oniro"
  },"82": {
    "doc": "Eclipse Oniro Project",
    "title": "The Project",
    "content": "The Oniro Project was established through a first-of-its-kind agreement between two major global open-source foundations - The Eclipse Foundation and The OpenAtom Foundation. The collaboration aims to drive the development and global adoption of OpenHarmony. Operating within the framework of the Eclipse Foundation as a dedicated project and Working Group, the project leverages the Eclipse Foundation’s extensive experience in open-source governance. This approach fosters transparency and encourages active community participation in the project’s development and ongoing evolution. The project encompasses a diverse array of enhancements, with a particular emphasis on application frameworks, system-level OS components, and integrated development environments (IDE). It also incorporates an advanced toolchain dedicated to ensuring compliance with intellectual property and licensing standards. At its heart, Oniro is committed to providing seamless interoperability, modularization, and an intuitive, visually appealing user interface. As a versatile platform, Oniro offers comprehensive support for a variety of global technologies and applications across multiple sectors, including Consumer Electronics, Home Appliances, Industrial IoT, Smart Home, and Multimedia. You can learn more about Oniro Project by going to https://oniroproject.org. ",
    "url": "/#the-project",
    
    "relUrl": "/#the-project"
  },"83": {
    "doc": "Eclipse Oniro Project",
    "title": "The Code",
    "content": "The Oniro code is hosted in GitHub Eclipse Oniro for OpenHarmony organization. Additionally, the project mirrors all repositories from Gitee OpenHarmony organization to GitHub Eclipse Oniro Mirrors organization. These mirrored repositories are read-only and consumed by Eclipse Oniro build system. The mirroring aims to enhance speed and reliability of the repositories’ access. Additionally, it simplifies forking and consumption on GitHub. To keep the mirrors current, a synchronization CI workflow runs every 24 hours, updating them with the latest changes. ",
    "url": "/#the-code",
    
    "relUrl": "/#the-code"
  },"84": {
    "doc": "Eclipse Oniro Project",
    "title": "Quick Start",
    "content": "To quickly start working with the code and building Oniro please follow our concise tutorial. For those interested in experiencing its functionality on actual hardware, as a starting point, we recommend the HiHope HH-SCDAYU200 development kit, which is based on Rockchip’s RK3568 processor. This kit is readily accessible in Europe and the USA, offering convenience for developers in these regions. ",
    "url": "/#quick-start",
    
    "relUrl": "/#quick-start"
  },"85": {
    "doc": "Eclipse Oniro Project",
    "title": "Chat with Us",
    "content": "The Oniro Project engages in community discussions primarily through Eclipse Matrix rooms, and we warmly welcome everyone to join. Whether you seek assistance, wish to contribute, or are keen on interacting with our maintainers, contributors, and community members, the Oniro Project room is the ideal starting point. You can find a full list of Eclipse Oniro chat rooms here. Matrix provides a secure, decentralized communication network, allowing the use of existing accounts from any server. Don’t have a Matrix account? Your Eclipse Foundation account can seamlessly fulfill this role. Creating an Eclipse Foundation account is a straightforward process, ensuring quick and easy access. ",
    "url": "/#chat-with-us",
    
    "relUrl": "/#chat-with-us"
  },"86": {
    "doc": "Eclipse Oniro Project",
    "title": "Issue Reporting",
    "content": "We welcome feedback and issue reports for continuous improvement of the project. If you encounter any problems or bugs, kindly report them on our GitHub issues page. Your contributions are valuable to the project’s development. ",
    "url": "/#issue-reporting",
    
    "relUrl": "/#issue-reporting"
  },"87": {
    "doc": "Eclipse Oniro Project",
    "title": "Eclipse Oniro Project",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"88": {
    "doc": "Introduction to ArkTS",
    "title": "Introduction",
    "content": "Welcome to the tutorial for ArkTS, a TypeScript-based programming language designed specifically to build high-performance mobile applications. ArkTS is optimized to provide better performance and efficiency, while still maintaining the familiar syntax of TypeScript. ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#introduction",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#introduction"
  },"89": {
    "doc": "Introduction to ArkTS",
    "title": "Basic Syntax Overview",
    "content": "Text Source With a basic understanding of the ArkTS language, let’s look into the composition of ArkTS through an example. As shown below, when the user clicks the button, the text content changes from Hello World to Hello ArkUI. Figure 1 Example effect drawing . In this example, the basic composition of ArkTS is as follows. Figure 2 Basic composition of ArkTS . NOTE . The name of a custom variable cannot be the same as that of any universal attribute or event. | Decorator: design pattern used to decorate classes, structs, methods, and variables to assign special meanings to them. In the preceding sample code, @Entry, @Component, and @State are decorators. | @Component indicates a custom component | @Entry indicates that the custom component is an entry component | @State indicates a state variable in the component, whose change will trigger the UI to re-render. | . | UI description: declarative description of the UI structure, such as the code block of the build() method. | Custom component: reusable UI unit, which can be used with other components, such as the struct Hello decorated by @Component. | Built-in component: default basic or container component preset in ArkTS, which can be directly invoked, such as Column, Text, Divider, and Button components in the sample code. | Attribute method: method used to configure component attributes, such as fontSize(), width(), height(), and backgroundColor(). You can configure multiple attributes of a component in method chaining mode. | Event method: method used to add the logic for a component to respond to an event. In the sample code, onClick() following Button is an event method. You can configure response logic for multiple events in method chaining mode. | . ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#basic-syntax-overview",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#basic-syntax-overview"
  },"90": {
    "doc": "Introduction to ArkTS",
    "title": "Key Features",
    "content": " ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#key-features",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#key-features"
  },"91": {
    "doc": "Introduction to ArkTS",
    "title": "Declarative UI",
    "content": "Text Source ArkTS declaratively combines and extends components to describe the UI of an application. It also provides basic methods for configuring attributes, events, and child components to help you implement application interaction logic. Creating a Component . Depending on the builder, you can create components with or without mandatory parameters. NOTE The new operator is not required when you create a component. Without Mandatory Parameters . A struct without mandatory parameters is a component defined with empty parentheses. For example, the Divider component: . Column() { Text('item 1') Divider() Text('item 2') } . With Mandatory Parameters . A struct with mandatory parameters is a component whose API definition expects parameters enclosed in parentheses. | Set the mandatory parameter src of the Image component as follows: . Image('https://xyz/test.jpg') . | Set the optional parameter content of the Text component. // Parameter of the string type Text('test') // Add application resources in $r format, which can be used in multi-language scenarios. Text($r('app.string.title_value')) // No mandatory parameters Text() . | You can also use variables or expressions to assign values to parameters. The result type returned by an expression must meet the parameter type requirements. For example, to set a variable or expression to construct the Image and Text components: . Image(this.imagePath) Image('https://' + this.imageUrl) Text(`count: ${this.count}`) . | . Configuring Attributes . Use chainable attribute methods to configure the style and other attributes of built-in components. It is recommended that a separate line be used for each attribute method. | Example of configuring the fontSize attribute for the Text component: . Text('test') .fontSize(12) . | Example of configuring multiple attributes for the Image component: . Image('test.jpg') .alt('error.jpg') .width(100) .height(100) . | Attribute methods accept expressions and variables as well constant parameters. Text('hello') .fontSize(this.size) Image('test.jpg') .width(this.count % 2 === 0 ? 100 : 200) .height(this.offset + 100) . | For built-in components, ArkUI also predefines some enumeration types. These enumeration types can be passed as parameters, as long as they meet the parameter type requirements. Example of configuring the font color and style of the Text component: . Text('hello') .fontSize(20) .fontColor(Color.Red) .fontWeight(FontWeight.Bold) . | . Handling Events . Use chainable event methods to configure events supported by built-in components. It is recommended that a separate line be used for each event method. | Example of using an arrow function expression to configure the event of a component: . Button('Click me') .onClick(() =&gt; { this.myText = 'ArkUI'; }) . | Example of using an arrow function expression to configure the event of a component (() =&gt; {…} must be used to ensure that the function is bound to the component and complies with the ArkTS syntax specifications): . Button('add counter') .onClick(() =&gt; { this.counter += 2; }) . | Example of using a component’s member function to configure the event of the component, where this binding is needed: (This usage is not recommended in ArkTS.) . myClickHandler(): void { this.counter += 2; } ... Button('add counter') .onClick(this.myClickHandler.bind(this)) . | Example of using an arrow function expression for a declaration, where this binding is not needed: . fn = () =&gt; { console.info(`counter: ${this.counter}`) this.counter++ } ... Button('add counter') .onClick(this.fn) . | . NOTE In arrow functions, this inherits its value from the surrounding (lexical) scope in which they are defined. This means that, in anonymous functions, this may present an unclear reference and is therefore not allowed in ArkTS. Configuring Child Components . For a component with child components, for example, a container component, add the UI descriptions of the child components inside parentheses. The Column, Row, Stack, Grid, and List components are all container components. | Simple example of configuring child components for the Column component: . Column() { Text('Hello') .fontSize(100) Divider() Text(this.myText) .fontSize(100) .fontColor(Color.Red) } . | Example of nested child components in the Column component:. Column() { Row() { Image('test1.jpg') .width(100) .height(100) Button('click +1') .onClick(() =&gt; { console.info('+1 clicked!'); }) } } . | . ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#declarative-ui",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#declarative-ui"
  },"92": {
    "doc": "Introduction to ArkTS",
    "title": "Componentization",
    "content": "Components are the fundamental building blocks of a user interface. Everything you see on the screen is created by combining multiple components. Designing a user interface is essentially about assembling these components in a meaningful way. ArkTS provides a wide range of built-in components, such as Text, Button, and Image. Moreover, it allows developers to create custom components to better suit specific requirements. Basic Component . Row Component . The &lt;Row&gt; component lays out child components horizontally. NOTE . This component is supported since API version 7. Updates will be marked with a superscript to indicate their earliest API version. Child Components . Supported . APIs . Row(value?:{space?: number | string }) . This API can be used in ArkTS widgets since API version 9. Parameters . | Name | Type | Mandatory | Description | . | space | number | string | No | Horizontal spacing between two adjacent child components.Since API version 9, this parameter does not take effect when it is set to a negative number or when justifyContent is set to FlexAlign.SpaceBetween, FlexAlign.SpaceAround or FlexAlign.SpaceEvenly.Default value: 0, in vpNOTEThe value can be a number greater than or equal to 0 or a string that can be converted to a number. | . Attributes . | Name | Type | Description | . | alignItems | VerticalAlign | Alignment mode of child components in the vertical direction.Default value: VerticalAlign.CenterThis API can be used in ArkTS widgets since API version 9. | . | justifyContent | FlexAlign | Alignment mode of the child components in the horizontal direction.Default value: FlexAlign.StartThis API can be used in ArkTS widgets since API version 9. | . NOTE . During row layout, child components do not shrink if flexShrink is not set for them. In this case, the total size of the child components on the main axis can exceed the size of the container on the main axis. Example . // xxx.ets @Entry @Component struct RowExample { build() { Column({ space: 5 }) { // Set the horizontal spacing between two adjacent child components to 5. Text('space').width('90%') Row({ space: 5 }) { Row().width('30%').height(50).backgroundColor(0xAFEEEE) Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').height(107).border({ width: 1 }) // Set the alignment mode of the child components in the vertical direction. Text('alignItems(Bottom)').width('90%') Row() { Row().width('30%').height(50).backgroundColor(0xAFEEEE) Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').alignItems(VerticalAlign.Bottom).height('15%').border({ width: 1 }) Text('alignItems(Center)').width('90%') Row() { Row().width('30%').height(50).backgroundColor(0xAFEEEE) Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').alignItems(VerticalAlign.Center).height('15%').border({ width: 1 }) // Set the alignment mode of the child components in the horizontal direction. Text('justifyContent(End)').width('90%') Row() { Row().width('30%').height(50).backgroundColor(0xAFEEEE) Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').border({ width: 1 }).justifyContent(FlexAlign.End) Text('justifyContent(Center)').width('90%') Row() { Row().width('30%').height(50).backgroundColor(0xAFEEEE) Row().width('30%').height(50).backgroundColor(0x00FFFF) }.width('90%').border({ width: 1 }).justifyContent(FlexAlign.Center) }.width('100%') } } . Column Component . The &lt;Column&gt; component lays out child components vertically. NOTE . This component is supported since API version 7. Updates will be marked with a superscript to indicate their earliest API version. Child Components . Supported . APIs . Column(value?: {space?: string | number}) . This API can be used in ArkTS widgets since API version 9. Parameters . | Name | Type | Mandatory | Description | . | space | string | number | No | Vertical spacing between two adjacent child components.Since API version 9, this parameter does not take effect when it is set to a negative number or when justifyContent is set to FlexAlign.SpaceBetween, FlexAlign.SpaceAround or FlexAlign.SpaceEvenly.Default value: 0Unit: vpNOTEThe value can be a number greater than or equal to 0 or a string that can be converted to a number. | . Attributes . | Name | Type | Description | . | alignItems | HorizontalAlign | Alignment mode of the child components in the horizontal direction.Default value: HorizontalAlign.CenterThis API can be used in ArkTS widgets since API version 9. | . | justifyContent | FlexAlign | Alignment mode of the child components in the vertical direction.Default value: FlexAlign.StartThis API can be used in ArkTS widgets since API version 9. | . NOTE . During column layout, child components do not shrink if flexShrink is not set for them. In this case, the total size of the child components on the main axis can exceed the size of the container on the main axis. Example . // xxx.ets @Entry @Component struct ColumnExample { build() { Column({ space: 5 }) { // Set the vertical spacing between two adjacent child components to 5. Text('space').width('90%') Column({ space: 5 }) { Column().width('100%').height(30).backgroundColor(0xAFEEEE) Column().width('100%').height(30).backgroundColor(0x00FFFF) }.width('90%').height(100).border({ width: 1 }) // Set the alignment mode of the child components in the horizontal direction. Text('alignItems(Start)').width('90%') Column() { Column().width('50%').height(30).backgroundColor(0xAFEEEE) Column().width('50%').height(30).backgroundColor(0x00FFFF) }.alignItems(HorizontalAlign.Start).width('90%').border({ width: 1 }) Text('alignItems(End)').width('90%') Column() { Column().width('50%').height(30).backgroundColor(0xAFEEEE) Column().width('50%').height(30).backgroundColor(0x00FFFF) }.alignItems(HorizontalAlign.End).width('90%').border({ width: 1 }) Text('alignItems(Center)').width('90%') Column() { Column().width('50%').height(30).backgroundColor(0xAFEEEE) Column().width('50%').height(30).backgroundColor(0x00FFFF) }.alignItems(HorizontalAlign.Center).width('90%').border({ width: 1 }) // Set the alignment mode of the child components in the vertical direction. Text('justifyContent(Center)').width('90%') Column() { Column().width('90%').height(30).backgroundColor(0xAFEEEE) Column().width('90%').height(30).backgroundColor(0x00FFFF) }.height(100).border({ width: 1 }).justifyContent(FlexAlign.Center) Text('justifyContent(End)').width('90%') Column() { Column().width('90%').height(30).backgroundColor(0xAFEEEE) Column().width('90%').height(30).backgroundColor(0x00FFFF) }.height(100).border({ width: 1 }).justifyContent(FlexAlign.End) }.width('100%').padding({ top: 5 }) } } . You can learn more about basic components here. Custom Component . In ArkUI, components are the visual elements of the interface, divided into built-in components provided by the framework and custom components created by developers. Relying solely on built-in components can lead to rigid, hard-to-maintain designs. Custom components help improve code reusability, separate UI from business logic, and support version upgrades. They offer key features such as: . | Combinable: Combine built-in and custom components with shared properties and methods. | Reusable: Easily reused across different parts of the app. | Data-driven updates: Maintain internal state and update the UI when state changes. | . Create a Custom Component . Basic Usage of Custom Component . The following example shows the basic usage of a custom component. // xxx.ets @Component struct HelloComponent { @State message: string = 'Hello, World!'; build() { // The HelloComponent custom component combines the &lt;Row&gt; and &lt;Text&gt; built-in components. Row() { Text(this.message) .onClick(() =&gt; { // The change of the state variable message drives the UI to be re-rendered. As a result, the text changes from \"Hello, World!\" to \"Hello, ArkUI!\". this.message = 'Hello, ArkUI!'; }) } } } . On Previewer, click Hello, World!, the text will change into Hello, ArkUI!. &lt;img src='./images/image-basic/image6.png' width=40%&gt; &lt;img src='./images/image-basic/image7.png' width=40%&gt; NOTE . To reference the custom component in another file, use the keyword export to export the component and then use import to import it to the target file. Multiple HelloComponent instances can be created in build() of other custom components. In this way, HelloComponent is reused by those custom components. @Entry @Component struct ParentComponent { build() { Column() { Text('ArkUI message') HelloComponent({ message: 'Hello World!' }); Divider() HelloComponent({message: 'Hello, World!'}); } } } . &lt;img src='./images/image-basic/image8.png' width=60%&gt; Basic Structure of a Custom Component . Basic structure are listed below: . | struct The definition of a custom component must start with the @Component struct followed by the component name, and then component body enclosed by curly brackets. No inheritance is allowed. You can omit the new operator when instantiating a struct. NOTE . The name or its class or function name of a custom component must be different from that of any built-in components. | @Component The @Component decorator can decorate only the structs declared by the struct keyword. When being decorated by @Component, a struct has the componentization capability. You must implement the build function for it to describe the UI. Each struct can be decorated by only one @Component. @Component can accept an optional parameter of the Boolean type. NOTE . This decorator can be used in ArkTS widgets since API version 9. An optional parameter of the Boolean type can be used in the @Component since API version 11. @Component struct MyComponent { } . | The build Function The build function is used to define the declarative UI description of a custom component. Every custom component must define a build function. @Component struct MyComponent { build() { } } . | @Entry A custom component decorated with @Entry is used as the default entry component of the page. Only one component can be decorated with @Entry in a single page. The @Entry decorator accepts an optional parameter of type LocalStorage. NOTE . This decorator can be used in ArkTS widgets since API version 9. Since API version 10, the @Entry decorator accepts an optional parameter of type LocalStorage or type EntryOptions. This decorator can be used in atomic services since API version 11. @Entry @Component struct MyComponent { } . | @Reusable Custom components decorated by @Reusable can be reused. NOTE . This decorator can be used in ArkTS widgets since API version 10. @Reusable @Component struct MyComponent { } . | . Rules for Custom Component Parameters . As can be learnt from preceding examples, a custom component can be created from a build method. During the creation, the custom component’s parameters are initialized based on the decorator rules. @Component struct MyComponent { private countDownFrom: number = 0; private color: Color = Color.Blue; build() { } } @Entry @Component struct ParentComponent { private someColor: Color = Color.Pink; build() { Column() { // Create an instance of MyComponent and initialize its countDownFrom variable with the value 10 and its color variable with the value this.someColor. MyComponent({ countDownFrom: 10, color: this.someColor }) } } } . In the following example, a function in the parent component is passed to the child component and called there. @Entry @Component struct Parent { @State cnt: number = 0 submit: () =&gt; void = () =&gt; { this.cnt++; } build() { Column() { Text(`${this.cnt}`) Son({ submitArrow: this.submit }) } } } @Component struct Son { submitArrow?: () =&gt; void build() { Row() { Button('add') .width(80) .onClick(() =&gt; { if (this.submitArrow) { this.submitArrow() } }) } .height(56) } } . Click the button defined in Son, Text result will be updated in Parent. &lt;img src='./images/image-basic/image9.png' width=40%&gt; &lt;img src='./images/image-basic/image10.png' width=40%&gt; Rules in build Function . Whatever declared in build() are called UI descriptions. UI descriptions must comply with the following rules: . | For an @Entry decorated custom component, exactly one root component is required under build(). This root component must be a container component. ForEach is not allowed at the top level. For an @Component decorated custom component, exactly one root component is required under build(). This root component is not necessarily a container component. ForEach is not allowed at the top level. @Entry @Component struct MyComponent { build() { // Exactly one root component is required, and it must be a container component. Row() { ChildComponent() } } } @Component struct ChildComponent { build() { // Exactly one root component is required, and it is not necessarily a container component. Image('test.jpg') } } . | Local variable declaration is not allowed. The following example should be avoided: . build() { // Avoid: declaring a local variable. let num: number = 1; } . | console.info can be used in the UI description only when it is in a method or function. The following example should be avoided: . build() { // Avoid: using console.info directly in UI description. console.info('print debug log'); } . | Creation of a local scope is not allowed. The following example should be avoided: . build() { // Avoid: creating a local scope. { // ... } } . | Only methods decorated by @Builder can be called. The parameters of built-in components can be the return values of TS methods. @Component struct ParentComponent { doSomeCalculations() { } calcTextValue(): string { return 'Hello World'; } @Builder doSomeRender() { Text(`Hello World`) } build() { Column() { // Avoid: calling a method not decorated by @Builder. this.doSomeCalculations(); // Prefer: Call an @Builder decorated method. this.doSomeRender(); // Prefer: Pass the return value of a TS method as the parameter. Text(this.calcTextValue()) } } } . | The switch syntax is not allowed. If conditional judgment is required, use the if statement. Refer to the code snippet below. build() { Column() { // Avoid: using the switch syntax. switch (expression) { case 1: Text('...') break; case 2: Image('...') break; default: Text('...') break; } // Correct usage: Use if. if(expression == 1) { Text('...') } else if(expression == 2) { Image('...') } else { Text('...') } } } . | Expressions are not allowed except for the if component. Refer to the code snippet below. build() { Column() { // Avoid: expressions. (this.aVar &gt; 10) ? Text('...') : Image('...') // Positive example: Use if for judgment. if(this.aVar &gt; 10) { Text('...') } else { Image('...') } } } . | Directly changing a state variable is not allowed. The following example should be avoided: . @Component struct MyComponent { @State textColor: Color = Color.Yellow; @State columnColor: Color = Color.Green; @State count: number = 1; build() { Column() { // Avoid: directly changing the value of count in the &lt;Text&gt; component. Text(`${this.count++}`) .width(50) .height(50) .fontColor(this.textColor) .onClick(() =&gt; { this.columnColor = Color.Red; }) Button(\"change textColor\").onClick(() =&gt;{ this.textColor = Color.Pink; }) } .backgroundColor(this.columnColor) } } . In ArkUI state management, UI re-render is driven by state. | . &lt;img src='./images/image-basic/image11.png' width=40%&gt; Therefore, do not change any state variable in the build() or @Builder decorated method of a custom component. Otherwise, loop rendering may result. Universal Style of a Custom Component . The universal style of a custom component is configured by the chain call. @Component struct ChildComponent { build() { Button(`Hello World`) } } @Entry @Component struct MyComponent { build() { Row() { ChildComponent() .width(200) .height(300) .backgroundColor(Color.Red) } } } . &lt;img src=’./images/image-basic/image12.png’ width=40%&gt; . NOTE . When ArkUI sets styles for custom components, an invisible container component is set for ChildComponent. These styles are set on the container component instead of the Button component of ChildComponent. As seen from the rendering result, the red background color is not directly applied to the button. Instead, it is applied to the container component that is invisible to users where the button is located. Page and Custom Component Lifecycle . Before we dive into the page and custom component lifecycle, it would be helpful to learn the relationship between custom components and pages. | Custom component: @Component decorated UI unit, which can combine multiple built-in components for component reusability and invoke component lifecycle callbacks. | Page: UI page of an application. A page can consist of one or more custom components. A custom component decorated with @Entry is used as the entry component of the page. Exactly one component is decorated with @Entry in a single source file. Only components decorated by @Entry can invoke the lifecycle callbacks of a page. | . The following lifecycle callbacks are provided for a page, that is, a custom component decorated with @Entry: . | onPageShow: Invoked each time the page is displayed, for example, during page redirection or when the application is switched to the foreground. | onPageHide: Invoked each time the page is hidden, for example, during page redirection or when the application is switched to the background. | onBackPress: Invoked when the user clicks the Back button. | . The following lifecycle callbacks are provided for a custom component decorated with @Component: . | aboutToAppear: Invoked when the custom component is about to appear. Specifically, it is invoked after a new instance of the custom component is created and before its build function is executed. | aboutToDisappear: Invoked when the custom component is about to be destroyed. Do not change state variables in the aboutToDisappear function as doing this can cause unexpected errors. For example, the modification of the @Link decorated variable may cause unstable application running. | . The following figure shows the lifecycle of a component (page) decorated with @Entry. The following example shows when the lifecycle callbacks are invoked: . // Index.ets import router from '@ohos.router'; @Entry @Component struct MyComponent { @State showChild: boolean = true; @State btnColor:string = \"#FF007DFF\" // Only components decorated by @Entry can call the lifecycle callbacks of a page. onPageShow() { console.info('Index onPageShow'); } // Only components decorated by @Entry can call the lifecycle callbacks of a page. onPageHide() { console.info('Index onPageHide'); } // Only components decorated by @Entry can call the lifecycle callbacks of a page. onBackPress() { console.info('Index onBackPress'); this.btnColor =\"#FFEE0606\" return true // The value true means that the page executes its own return logic instead of the , and false (default) means that the default return logic is used. } // Component lifecycle aboutToAppear() { console.info('MyComponent aboutToAppear'); } // Component lifecycle aboutToDisappear() { console.info('MyComponent aboutToDisappear'); } build() { Column() { // When this.showChild is true, create the Child child component and invoke Child aboutToAppear. if (this.showChild) { Child() } // When this.showChild is false, delete the Child child component and invoke Child aboutToDisappear. Button('delete Child') .margin(20) .backgroundColor(this.btnColor) .onClick(() =&gt; { this.showChild = false; }) // Push to the page and execute onPageHide. Button('push to next page') .onClick(() =&gt; { router.pushUrl({ url: 'pages/page' }); }) } } } @Component struct Child { @State title: string = 'Hello World'; // Component lifecycle aboutToDisappear() { console.info('[lifeCycle] Child aboutToDisappear') } aboutToAppear() { console.info('[lifeCycle] Child aboutToAppear') } build() { Text(this.title).fontSize(50).margin(20).onClick(() =&gt; { this.title = 'Hello ArkUI'; }) } } . // page.ets @Entry @Component struct page { @State textColor: Color = Color.Black; @State num: number = 0 onPageShow() { this.num = 5 } onPageHide() { console.log(\"page onPageHide\"); } onBackPress() {// If the value is not set, false is used. this.textColor = Color.Grey this.num = 0 } aboutToAppear() { this.textColor = Color.Blue } build() { Column() { Text (`num: ${this.num}`) .fontSize(30) .fontWeight(FontWeight.Bold) .fontColor(this.textColor) .margin(20) .onClick(() =&gt; { this.num += 5 }) } .width('100%') } } . In the preceding example, the Index page contains two custom components. One is MyComponent decorated with @Entry, which is also the entry component (root node) of the page. The other is Child, which is a child component of MyComponent. Only components decorated by @Entry can call the page lifecycle callbacks. Therefore, the lifecycle callbacks of the Index page – onPageShow, onPageHide, and onBackPress, are declared in MyComponent. In MyComponent and its child components, component lifecycle callbacks – aboutToAppear and aboutToDisappear – are also declared. | The initialization process of application cold start is as follows: MyComponent aboutToAppear -&gt; MyComponent build -&gt; Child aboutToAppear -&gt; Child build -&gt; Child build execution completed -&gt; MyComponent build execution completed -&gt; Index onPageShow . | When delete Child is clicked, the value of this.showChild linked to if changes to false. As a result, the Child component is deleted, and the Child aboutToDisappear callback is invoked. | When push to next page is clicked, the router.pushUrl API is called to jump to the next page. As a result, the Index page is hidden, and the Index onPageHide callback is invoked. As the called API is router.pushUrl, which results in the Index page being hidden, but not destroyed, only the onPageHide callback is invoked. After a new page is displayed, the process of initializing the lifecycle of the new page is executed. | If router.replaceUrl is called, the Index page is destroyed. In this case, the execution of lifecycle callbacks changes to: Index onPageHide -&gt; MyComponent aboutToDisappear -&gt; Child aboutToDisappear. As aforementioned, a component is destroyed by directly removing it from the component tree. Therefore, aboutToDisappear of the parent component is called first, followed by aboutToDisappear of the child component, and then the process of initializing the lifecycle of the new page is executed. | When the Back button is clicked, the Index onBackPress callback is invoked, and the current Index page is destroyed. | When the application is minimized or switched to the background, the Index onPageHide callback is invoked. As the current Index page is not destroyed, aboutToDisappear of the component is not executed. When the application returns to the foreground, the Index onPageShow callback is invoked. | When the application exits, the following callbacks are executed in order: Index onPageHide -&gt; MyComponent aboutToDisappear -&gt; Child aboutToDisappear. | . More Usage . | Custom Component Layout | Freezing a Custom Component | . ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#componentization",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#componentization"
  },"93": {
    "doc": "Introduction to ArkTS",
    "title": "State Management",
    "content": "In previous examples, most of the pages built are static pages, which are delivered to the end user without having to be processed. If you are building dynamic, interactive pages, you need to handle state management. Figure 1: State managed UI . In the preceding example, the interaction between the user and the application triggers an update in the text state, which in turn triggers re-rendering of the UI. As a result, the Hello World text changes to Hello ArkUI. In a declarative UI framework, the UI is the result of the application’s runtime state. You define a UI model with the state as a parameter, and when the state changes, the UI updates accordingly. This update process is known as the state management mechanism in ArkUI. For custom components, any variable that affects the UI must be decorated. Without a decorator, the UI renders only once at initialization and won’t update with changes. The diagram below illustrates the relationship between state and view. | View (UI): UI rendering, which is visual representation of the UI description in the build method and @Builder decorated method. | State: data that drives the UI to re-render. State data is changed by invoking the event method of the component. The change of the state data triggers the re-rendering of the UI. | . Basic Concepts . | State Variables: A variable decorated by a state decorator. Its value change will trigger UI re-renders. For example: @State num: number = 1; // 'num' is the state variable, '@State' is the decorator. | Regular Variables: A variable that is not decorated by a state decorator and is usually used for auxiliary calculation. Its value change will not trigger UI re-renders. In the following example, the increaseBy variable is a regular variable: private increaseBy: number = 1; // 'increaseBy' is a regular variable. | Data Sources/Synchronization Sources: Original source of a state variable, which can be synchronized to different state data. Generally, it is the data passed from the parent component to the child component. For example: count: 1; // 'count' is the data source. | Named Argument Mechanism: A mechanism where the parent component passes state variables to the child component by specifying parameters. It is the primary means of passing synchronization parameters from the parent component to the child component. Example: CompA: ({ aProp: this.aProp }); . | Initialization from Parent Component: A process where the parent component uses the named parameter mechanism to pass specified parameters to the child component. The default value used in local initialization will be overwritten by the value passed from the parent component. Example: | . @Component struct MyComponent { @State count: number = 0; // State variable private increaseBy: number = 1; // Regular variable build() { } } @Component struct Parent { build() { Column() { // Initialize from parent, overriding local default values MyComponent({ count: 1, increaseBy: 2 }) } } } . | Child Component Initialization: A capability to pass state variables to the child component to initialize the corresponding state variables therein. The example is the same as above. | Local Initialization: A process where a value is assigned to a variable as its default value in the variable declaration. Example: @State count: number = 0; . | . Decorator Overview . ArkUI provides a diverse array of decorators. You can use these decorators to observe state variables changes within a component or globally and pass the changes between different component levels (for example, between parent and child components or grandparent and grandchild components). According to the scope of the state variable, decorators can be roughly classified into the following types: . | Decorators for managing the state of a component: implement state management at the component level by allowing for observation of state changes within a component and changes at different component levels. The observation is limited to state changes in the same component tree, that is, on the same page. | Decorators for managing the state of an application: implement global state management of an application by allowing for observation of state changes on different pages or even different UIAbility components. | . According to the data transfer mode and synchronization type, decorators can also be classified into the following types: . | Decorators that allow for one-way (read-only) transfer . | Decorators that allow for two-way (mutable) transfer . | . The following figure illustrates the decorators. You can use these decorators at your disposal to implement linkage between data and the UI. In the preceding figure, the decorators in the components area are used for state management at the component level, while others are used for state management at the application level. You can use @StorageLink/@LocalStorageLink to implement two-way synchronization of the application and component state, and @StorageProp/@LocalStorageProp to implement one-way synchronization. NOTE . To start, use @State, @Prop and @Link decorator is enough for simple development. Decorators for component state management . | @State: An @State decorated variable holds the state of the owning component. It can be the source of one- or two-way synchronization with child components. When the variable changes, the dependent component will be updated. | @Prop: An @Prop decorated variable can create one-way synchronization with a variable of its parent component. @Prop decorated variables are mutable, but changes are not synchronized to the parent component. | @Link: An @Link decorated variable creates two-way synchronization with a variable of its parent component. When the @Link decorated variable has its value changed, its source is updated as well; when the source updates, the @Link decorated variable will do as well. | @Provide/@Consume: Variables decorated by @Provide/@Consume are used for data synchronization across component levels. The components can be bound to the variables through aliases or attribute names. Data does not need to be passed through the named parameter mechanism. | @Observed: @Observed is a class decorator. You can use it to decorate the class that has multiple levels of nested objects or arrays to be observed. Note that @Observed must be used with @ObjectLink for two-way synchronization or with @Prop for one-way synchronization. | @ObjectLink: An @ObjectLink decorated variable is used with an @Observed decorated class of the parent component for two-way data synchronization. It is applicable in scenarios involving multiple levels of nested objects or arrays in the class. | . NOTE . Only @Observed/@ObjectLink can be used to observe changes of nested attributes. Other decorators can be used to observe changes of attributes at the first layer only. Decorators for application state management . | AppStorage: a special LocalStorage singleton instance. It is an application-wide database bound to the application process and can be linked to components through the @StorageProp and @StorageLink decorators. | AppStorage is the hub for application state. Data that needs to interact with components (UI) is stored in AppStorage, including PersistentStorage and Environment data. The UI accesses the data through the decorators or APIs provided by AppStorage. | LocalStorage: an in-memory “database” for the application state declared by the application and typically used to share state across pages. It can be linked to the UI through the @LocalStorageProp and @LocalStorageLink decorators. | . Other State Management Features . @Watch: listens for the changes of state variables. $$operator: provides a TS variable by-reference to a built-in component so that the variable value and the internal state of that component are kept in sync. ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#state-management",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#state-management"
  },"94": {
    "doc": "Introduction to ArkTS",
    "title": "Event Binding",
    "content": "Universal Events . This tutorial will introduce Touchscreen Event only, you can redirect the link to learn more like Focus Event and Keyboard and Mouse Event. Touchscreen events are events triggered when a finger or stylus is placed on, moved along, or lifted from a component. Events like click event, touch event are most often used. Click Event . A click event is triggered when a complete press and lift action is performed by using a finger or a stylus. When a click event occurs, the following callback is triggered: . onClick(event: (event?: ClickEvent) =&gt; void) . The event parameter provides the coordinates of the click relative to the window or component as well as the event source where the click occurs, for example, a button, a click on which shows or hides an image. @Entry @Component struct IfElseTransition { @State flag: boolean = true; @State btnMsg: string = 'show'; build() { Column() { Button(this.btnMsg).width(80).height(30).margin(30) .onClick(() =&gt; { if (this.flag) { this.btnMsg = 'hide'; } else { this.btnMsg = 'show'; } // Click the button to show or hide the image. this.flag = !this.flag; }) if (this.flag) { Image($r('app.media.icon')).width(200).height(200) } }.height('100%').width('100%') } } . Figure 1 Showing or hiding an image through the click event of a button . Touch Event . A touch event is triggered when a finger or stylus is placed on, moved along, or lifted from a component. onTouch(event: (event?: TouchEvent) =&gt; void) . | If event.type is TouchType.Down, the finger or stylus is placed on the component. | If event.type is TouchType.Up, the finger or stylus is lifted from the component. | If event.type is TouchType.Move, the finger or stylus is moved along the component. | . The touch event supports single and multi-touch interactions. Information about the touch event can be obtained using the event parameter, such as the location of the finger that triggers the event, unique identifier of the finger, finger information changed, and the input device source. // xxx.ets @Entry @Component struct TouchExample { @State text: string = ''; @State eventType: string = ''; build() { Column() { Button('Touch').height(40).width(100) .onTouch((event?: TouchEvent) =&gt; { if(event){ if (event.type === TouchType.Down) { this.eventType = 'Down'; } if (event.type === TouchType.Up) { this.eventType = 'Up'; } if (event.type === TouchType.Move) { this.eventType = 'Move'; } this.text = 'TouchType:' + this.eventType + '\\nDistance between touch point and touch element:\\nx: ' + event.touches[0].x + '\\n' + 'y: ' + event.touches[0].y + '\\nComponent globalPos:(' + event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\\nwidth:' + event.target.area.width + '\\nheight:' + event.target.area.height } }) Button('Touch').height(50).width(200).margin(20) .onTouch((event?: TouchEvent) =&gt; { if(event){ if (event.type === TouchType.Down) { this.eventType = 'Down'; } if (event.type === TouchType.Up) { this.eventType = 'Up'; } if (event.type === TouchType.Move) { this.eventType = 'Move'; } this.text = 'TouchType:' + this.eventType + '\\nDistance between touch point and touch element:\\nx: ' + event.touches[0].x + '\\n' + 'y: ' + event.touches[0].y + '\\nComponent globalPos:(' + event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\\nwidth:' + event.target.area.width + '\\nheight:' + event.target.area.height } }) Text(this.text) }.width('100%').padding(30) } } . Gesture Events . You can bind to each component different gesture events and design the logic for responding to these events. When a gesture is successfully recognized, the ArkUI framework notifies the component of the gesture recognition result through event callback. gesture (Common Gesture Binding Method) .gesture(gesture: GestureType, mask?: GestureMask) . gesture is a frequently used API for binding a gesture to a component. We don’t expand it in this tutorial but you can check some examples here if interested. ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#event-binding",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#event-binding"
  },"95": {
    "doc": "Introduction to ArkTS",
    "title": "Rendering Control",
    "content": "Overview . ArkUI uses the build() function of custom components and declarative UI description statements in the @builder decorator to build the corresponding UI. In declarative description statements, you can use rendering control statements in addition to system components to accelerate UI construction. These rendering control statements includes: . | Conditional statements that control whether components are displayed | Loop statements for repeated content that quickly generate components based on array data | Lazy loading statements for scenarios involving a large amount of data. | . if/else: Conditional Rendering . ArkTS provides conditional rendering. It supports the use of the if, else, and else if statements to display different content based on the application state. NOTE . This API can be used in ArkTS widgets since API version 9. Rules of Use . | The if, else, and else if statements are supported. | The conditional statements following if and else if can use state variables. | Conditional statements can be used within a container component to build different child components. | Conditional statements are “transparent” when it comes to the parent-child relationship of components. Rules about permissible child components must be followed when there is one or more if statements between the parent and child components. | The build function inside each conditional branch must follow the special rules for build functions. Each of such build functions must create one or more components. An empty build function that creates no components will result in a syntax error. | Some container components impose restrictions on the type or number of child components. When conditional statements are used in such components, these restrictions also apply to the components to be created by using the conditional statements. For example, when a conditional statement is used in the &lt;Grid&gt; container component, whose child components can only be &lt;GridItem&gt;, only the &lt;GridItem&gt; component can be used in the conditional statement. | . Update Mechanism . A conditional statement updates whenever a state variable used inside the if or else if condition changes. Specifically: . | The conditional statement re-evaluates the conditions. If the evaluation of the conditions changes, steps 2 and 3 are performed. Otherwise, no follow-up operation is required. | The ArkUI framework removes all child components that have been built. | The ArkUI framework executes the build function of the conditional branch again to add the generated child component to its parent component. If an applicable else branch is missing, no new build function will be executed. | . A condition can include Typescript expressions. As for any expression inside build functions, such an expression must not change any application state. Use Scenarios . Using if for Conditional Rendering . @Entry @Component struct ViewA { @State count: number = 0; build() { Column() { Text(`count=${this.count}`) if (this.count &gt; 0) { Text(`count is positive`) .fontColor(Color.Green) } Button('increase count') .onClick(() =&gt; { this.count++; }) Button('decrease count') .onClick(() =&gt; { this.count--; }) } } } . Each branch of the if statement includes a build function. Each of such build functions must create one or more components. On initial render, if will execute a build function and add the generated child component to its parent component. if updates whenever a state variable used inside the if or else if condition changes, and re-evaluates the conditions. If the evaluation of the conditions changes, it means that another branch of if needs to be built. In this case, the ArkUI framework will: . | Remove all previously rendered components (of the earlier branch). | Execute the build function of the branch and add the generated child component to its parent component. | . In the preceding example, if count increases from 0 to 1, then if updates, the condition count &gt; 0 is re-evaluated, and the evaluation result changes from false to true. Therefore, the positive branch build function will be executed, which creates a &lt;Text&gt; component and adds it to the &lt;Column&gt; parent component. If count changes back to 0 later, then the &lt;Text&gt; component will be removed from the &lt;Column&gt; component. Since there is no else branch, no new build function will be executed. Here is a preview of the example: . Click increase count, ‘count is positive’ will appear on the Previewer. if … else … and Child Component States . This example involves if… else… and a child component with an @State decorated variable. @Component struct CounterView { @State counter: number = 0; label: string = 'unknown'; build() { Row() { Text(`${this.label}`) Button(`counter ${this.counter} +1`) .onClick(() =&gt; { this.counter += 1; }) } } } @Entry @Component struct MainView { @State toggle: boolean = true; build() { Column() { if (this.toggle) { CounterView({ label: 'CounterView #positive' }) } else { CounterView({ label: 'CounterView #negative' }) } Button(`toggle ${this.toggle}`) .onClick(() =&gt; { this.toggle = !this.toggle; }) } } } . On first render, the CounterView (label: ‘CounterView #positive’) child component is created. This child component carries the @State decorated variable, named counter. When the CounterView.counter state variable is updated, the CounterView (label: ‘CounterView #positive’) child component is re-rendered, with its state variable value preserved. When the value of the MainView.toggle state variable changes to false, the if statement inside the MainView parent component gets updated, and subsequently the CounterView (label: ‘CounterView #positive’) child component is removed. At the same time, a new CounterView (label: ‘CounterView #negative’) child component is created, with the counter state variable set to the initial value 0. Here is a preview of the example: . NOTE . CounterView (label: ‘CounterView #positive’) and CounterView (label: ‘CounterView #negative’) are two distinct instances of the same custom component. When the if branch changes, there is no update to an existing child component or no preservation of state. The following example shows the required modifications if the value of counter needs to be preserved when the if condition changes: . @Component struct CounterView { @Link counter: number; label: string = 'unknown'; build() { Row() { Text(`${this.label}`) Button(`counter ${this.counter} +1`) .onClick(() =&gt; { this.counter += 1; }) } } } @Entry @Component struct MainView { @State toggle: boolean = true; @State counter: number = 0; build() { Column() { if (this.toggle) { CounterView({ counter: $counter, label: 'CounterView #positive' }) } else { CounterView({ counter: $counter, label: 'CounterView #negative' }) } Button(`toggle ${this.toggle}`) .onClick(() =&gt; { this.toggle = !this.toggle; }) } } } . Here, the @State decorated variable counter is owned by the parent component. Therefore, it is not destroyed when a CounterView component instance is destroyed. The CounterView component refers to the state by an @Link decorator. The state must be moved from a child to its parent (or parent of parent) to avoid losing it when the conditional content (or repeated content) is destroyed. ForEach: Rendering of Repeated Content . ForEach enables rendering of repeated content based on array type data. It must be used in a container component, and the component it returns must be one allowed inside the container component. For example, for rendering of list items, ForEach must be used in the &lt;List&gt; component. NOTE . This API is supported in ArkTS widgets since API version 9. Interface Description . ForEach( arr: Array, itemGenerator: (item: Object, index: number) =&gt; void, keyGenerator?: (item: Object, index: number) =&gt; string ) . The parameters are described in the table below. | Name | Type | Mandatory | Description | . | arr | Array&lt;Object&gt; | Yes | Data source, which is an array.NOTE- You can set this parameter to an empty array. In this case, no child component is created.- You can also set this parameter to a function whose return value is an array, for example, arr.slice (1, 3). However, the set function cannot change any state variables including the array itself. For example, Array.splice, Array.sort, and Array.reverse functions are not allowed, as they may change the array. | . | itemGenerator | (item: Object, index: number) =&gt; void | Yes | Component generator.- It generates a component for each data item in an array. - item: data item in the arr array.- (Optional) index: index of the data item in the arr array.NOTE- The type of the created component must be the one allowed inside the parent container component of ForEach. For example, a &lt;ListItem&gt; component is allowed only when the parent container component of ForEach is &lt;List&gt;. | . | keyGenerator | (item: Object, index: number) =&gt; string | No | Key generator.- It generates a unique and persistent key for each array item of the data source arr. The return value is the key generation rule you customize.- item: data item in the arr array.- (Optional) index: index of the data item in the arr array.NOTE- If this function is not specified, the default key generator of the framework is used: (item: T, index: number) =&gt; { return index + ‘__’ + JSON.stringify(item); }.- The key generator should not change any component state. | . NOTE . | The itemGenerator function can contain an if/else statement, and an if/else statement can contain ForEach. | On initial rendering, ForEach loads all data of the data source, creates a component for each data item, and mounts the created components to the render tree. If the data source contains a large number of items or performance is a critical concern, you are advised to use LazyForEach. | . Key Generation Rules . | During ForEach rendering, the system generates a unique, persistent key for each array item to identify the corresponding component. When the key changes, the ArkUI framework considers that the array element has been replaced or modified and creates a new component based on the new key. | ForEach provides a parameter named keyGenerator, which is in effect a function through which you can customize key generation rules. If no keyGenerator function is defined, the ArkUI framework uses the default key generator, that is, (item: Object, index: number) =&gt; { return index + ‘__’ + JSON.stringify(item); }. | The ArkUI framework has a set of specific judgment rules for ForEach key generation, which are mainly associated with the second parameter index of the itemGenerator function and the second parameter index of the keyGenerator function. The following figure shows the logic of the key generation rules. | . NOTE . The ArkUI framework warns of duplicate keys. If duplicate keys exist during UI re-rendering, the framework may not work properly. Component Creation Rules . After the key generation rules are determined, the itemGenerator function – the second parameter in ForEach – creates a component for each array item of the data source based on the rules. There are two cases for creating a component: initial rendering and non-initial rendering. Initial Rendering . When used for initial rendering, ForEach generates a unique key for each array item of the data source based on the key generation rules, and creates a component. @Entry @Component struct Parent { @State simpleList: Array&lt;string&gt; = ['one', 'two', 'three']; build() { Row() { Column() { ForEach(this.simpleList, (item: string) =&gt; { ChildItem({ item: item }) }, (item: string) =&gt; item) } .width('100%') .height('100%') } .height('100%') .backgroundColor(0xF1F3F5) } } @Component struct ChildItem { @Prop item: string; build() { Text(this.item) .fontSize(50) } } . The figure below shows the effect. Figure 1 Initial rendering when the ForEach data sources do not have the same key . In the preceding code snippets, the key generation rule is the return value item of the keyGenerator function. During ForEach rendering, keys (one, two, and three) are generated in sequence for data source array items, and corresponding child items are created and rendered to the UI. When the keys generated for different data items are the same, the behavior of the framework is unpredictable. For example, in the following code, when data items with the same key two are rendered by ForEach, only one ChildItem component, instead of multiple components with the same key, is created. @Entry @Component struct Parent { @State simpleList: Array&lt;string&gt; = ['one', 'two', 'two', 'three']; build() { Row() { Column() { ForEach(this.simpleList, (item: string) =&gt; { ChildItem({ item: item }) }, (item: string) =&gt; item) } .width('100%') .height('100%') } .height('100%') .backgroundColor(0xF1F3F5) } } @Component struct ChildItem { @Prop item: string; build() { Text(this.item) .fontSize(50) } } . The figure below shows the effect. Figure 2 Initial rendering when the ForEach data sources have the same key . In this example, the final key value generation rule is item. When ForEach traverses the data source simpleList and finds the key two whose index is 1, ForEach creates a component whose key is two based on the final key value generation rule and marks the component. When ForEach finds the key two whose index is 2, it does not create a component, because the key of the current item is also two according to the final key generation rule. Non-Initial Rendering . When ForEach is used for re-rendering (non-initial rendering), it checks whether the newly generated key already exists in the previous rendering. If the key does not exist, a new component is created. If the key exists, no new component is created; instead, the component corresponding to the key is re-rendered. For example, in the following code snippet, the value of the third item of the array is changed to “new three” through the click event, which triggers ForEach to perform re-rendering. @Entry @Component struct Parent { @State simpleList: Array&lt;string&gt; = ['one', 'two', 'three']; build() { Row() { Column() { Text('Change Value of Third Array Item') .fontSize(24) .fontColor(Color.Red) .onClick(() =&gt; { this.simpleList[2] = 'new three'; }) ForEach(this.simpleList, (item: string) =&gt; { ChildItem({ item: item }) .margin({ top: 20 }) }, (item: string) =&gt; item) } .justifyContent(FlexAlign.Center) .width('100%') .height('100%') } .height('100%') .backgroundColor(0xF1F3F5) } } @Component struct ChildItem { @Prop item: string; build() { Text(this.item) .fontSize(30) } } . The figure below shows the effect. Figure 3 Re-rendering with ForEach . From this example, you can see that @State can observe changes in the primitive array items of the simpleList data source. | When any array item in simpleList changes, ForEach is triggered for re-rendering. | ForEach traverses the new data source [‘one’, ‘two’, ‘new three’] and generates the corresponding keys one, two, and new three. | Because keys one and two already exist in the previous rendering, ForEach reuses the corresponding components and re-renders them. For the third array item “new three”, because a new key new three is generated for it based on the key generation rule item, ForEach creates a new component for it. | . Use Cases . ForEach is typically used in several cases: . | data source unchanged | data source changed (for example, when array items are inserted or deleted) | properties of data source array items changed | . Data Source Unchanged . If the data source remains unchanged, it can of a primitive data type. For example, when a page is loading, the skeleton screen may be used. @Entry @Component struct ArticleList { @State simpleList: Array&lt;number&gt; = [1, 2, 3, 4, 5]; build() { Column() { ForEach(this.simpleList, (item: number) =&gt; { ArticleSkeletonView() .margin({ top: 20 }) }, (item: number) =&gt; item.toString()) } .padding(20) .width('100%') .height('100%') } } @Builder function textArea(width: number | Resource | string = '100%', height: number | Resource | string = '100%') { Row() .width(width) .height(height) .backgroundColor('#FFF2F3F4') } @Component struct ArticleSkeletonView { build() { Row() { Column() { textArea(80, 80) } .margin({ right: 20 }) Column() { textArea('60%', 20) textArea('50%', 20) } .alignItems(HorizontalAlign.Start) .justifyContent(FlexAlign.SpaceAround) .height('100%') } .padding(20) .borderRadius(12) .backgroundColor('#FFECECEC') .height(120) .width('100%') .justifyContent(FlexAlign.SpaceBetween) } } . The figure below shows the effect. Figure 4 Skeleton screen . In this example, the data item item is used as the key generation rule. Because the array items of the data source simpleList are different, the uniqueness of the keys can be ensured. Data Source Changed . If data source array item changes, for example, when an array item is inserted or deleted, or has its index changed, the data source should be of the object array type, and a unique ID of the object is used as the final key. For example, after a pull-to-refresh gesture is performed, newly obtained data items are added to the tail of the data source array, resulting in an increase in the length of the data source array. class Article { id: string; title: string; brief: string; constructor(id: string, title: string, brief: string) { this.id = id; this.title = title; this.brief = brief; } } @Entry @Component struct ArticleListView { @State isListReachEnd: boolean = false; @State articleList: Array&lt;Article&gt; = [ new Article('001','Article 1','Abstract'), new Article('002','Article 2','Abstract'), new Article('003','Article 3','Abstract'), new Article('004','Article 4','Abstract'), new Article('005','Article 5','Abstract'), new Article ('006','Article 6','Abstract') ] loadMoreArticles() { this.articleList.push(new Article('007','New article','Abstract'); } build() { Column({ space: 5 }) { List() { ForEach(this.articleList, (item: Article) =&gt; { ListItem() { ArticleCard({ article: item }) .margin({ top: 20 }) } }, (item: Article) =&gt; item.id) } .onReachEnd(() =&gt; { this.isListReachEnd = true; }) .parallelGesture( PanGesture({ direction: PanDirection.Up, distance: 80 }) .onActionStart(() =&gt; { if (this.isListReachEnd) { this.loadMoreArticles(); this.isListReachEnd = false; } }) ) .padding(20) .scrollBar(BarState.Off) } .width('100%') .height('100%') .backgroundColor(0xF1F3F5) } } @Component struct ArticleCard { @Prop article: Article; build() { Row() { Image($r('app.media.icon')) .width(80) .height(80) .margin({ right: 20 }) Column() { Text(this.article.title) .fontSize(20) .margin({ bottom: 8 }) Text(this.article.brief) .fontSize(16) .fontColor(Color.Gray) .margin({ bottom: 8 }) } .alignItems(HorizontalAlign.Start) .width('80%') .height('100%') } .padding(20) .borderRadius(12) .backgroundColor('#FFECECEC') .height(120) .width('100%') .justifyContent(FlexAlign.SpaceBetween) } } . The following figure shows the initial screen (on the left) and the screen after a pull-to-refresh gesture (on the right). Figure 5 When the data source is changed . In this example, the ArticleCard component functions as a child component of the ArticleListView component and receives an Article object through the @Prop decorator to render article widgets. | When the list scrolls to the bottom, if the distance of finger movement exceeds the threshold 80, the loadMoreArticle() function is triggered. This function adds a new data item to the tail of the articleList data source, increasing the length of the data source. | Because the data source is decorated by @State, the ArkUI framework can detect the change of the data source length and trigger ForEach for re-rendering. | . Properties of Data Source Array Items Changed . If the data source array items are of the Object type, property changes of these array items cannot be detected by the ArkUI framework, because the framework cannot detect property changes of array items of complex types when the array is decorated by @State. As a result, re-rendering by ForEach is not performed. To trigger ForEach to perform re-rendering, use the @Observed and @ObjectLink decorators. In the following example, clicking the Like icon on the article list changes the number of likes for an article. @Observed class Article { id: string; title: string; brief: string; isLiked: boolean; likesCount: number; constructor(id: string, title: string, brief: string, isLiked: boolean, likesCount: number) { this.id = id; this.title = title; this.brief = brief; this.isLiked = isLiked; this.likesCount = likesCount; } } @Entry @Component struct ArticleListView { @State articleList: Array&lt;Article&gt; = [ new Article('001','Article 0','Abstract', false, 100), new Article('002','Article 1','Abstract', false, 100), new Article('003','Article 2','Abstract', false, 100), new Article('004','Article 4','Abstract', false, 100), new Article('005','Article 5','Abstract', false, 100), new Article('006','Article 6','Abstract', false, 100), ]; build() { List() { ForEach(this.articleList, (item: Article) =&gt; { ListItem() { ArticleCard({ article: item }) .margin({ top: 20 }) } }, (item: Article) =&gt; item.id) } .padding(20) .scrollBar(BarState.Off) .backgroundColor(0xF1F3F5) } } @Component struct ArticleCard { @ObjectLink article: Article; handleLiked() { this.article.isLiked = !this.article.isLiked; this.article.likesCount = this.article.isLiked ? this.article.likesCount + 1 : this.article.likesCount - 1; } build() { Row() { Image($r('app.media.icon')) .width(80) .height(80) .margin({ right: 20 }) Column() { Text(this.article.title) .fontSize(20) .margin({ bottom: 8 }) Text(this.article.brief) .fontSize(16) .fontColor(Color.Gray) .margin({ bottom: 8 }) Row() { Image(this.article.isLiked ? $r('app.media.iconLiked') : $r('app.media.iconUnLiked')) .width(24) .height(24) .margin({ right: 8 }) Text(this.article.likesCount.toString()) .fontSize(16) } .onClick(() =&gt; this.handleLiked()) .justifyContent(FlexAlign.Center) } .alignItems(HorizontalAlign.Start) .width('80%') .height('100%') } .padding(20) .borderRadius(12) .backgroundColor('#FFECECEC') .height(120) .width('100%') .justifyContent(FlexAlign.SpaceBetween) } } . The following figure shows the initial screen (on the left) and the screen after the Like icon of Article 1 is clicked (on the right). Figure 6 When properties of data source array items are changed . In this example, the Article class is decorated by the @Observed decorator. The parent component ArticleListView passes an Article object instance to the child component ArticleCard, and the child component uses the @ObjectLink decorator to receive the instance. | When the Like icon of Article 1 is clicked, the handleLiked function of the ArticleCard component is triggered. This function changes the values of the isLiked and likesCount properties of the article instance in the component pertaining to Article 1. | Because article in the child component ArticleCard uses the @ObjectLink decorator, the parent and child components share the same article data. As such, the values of isLiked and likedCounts of the first array item of articleList in the parent component are changed synchronously. | When the parent component detects property changes of the data source array items, ForEach is triggered for re-rendering. | Here, the ForEach key generation rule is the id property value of the array item. If ForEach traverses the new data source and finds no changes in the id values, no component is created. | When the ArticleCard component corresponding to the first array item is rendered, the obtained values of isLiked and** likesCount** are the new values. | . Suggestions . | Avoid including the data item index in the final key generation rule to prevent unexpected rendering results and deteriorated rendering performance. If including index is required, for example, when the list needs to be rendered based on the index, prepare for the performance loss resulting from component creation by ForEach to account for data source changes. | To ensure unique keys for array items of the Object type, you are advised to use the unique IDs of objects as keys. | Data items of primitive data types do not have a unique ID. If you use the primitive data type itself as the key, you must ensure that the array items are not duplicate. In scenarios where the data source changes, you are advised to convert the array of a primitive data type into an array of the Object type with the id property, and then use the id property as the key generation rule. | . ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html#rendering-control",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html#rendering-control"
  },"96": {
    "doc": "Introduction to ArkTS",
    "title": "Introduction to ArkTS",
    "content": "Content Table: Introduction Basic Syntax Overview Key Features . | Declarative UI | Componentization . | Basic Component | Custom Component | . | State Management . | Basic Concepts | Decorator Overview . | Decorators for component state management | Decorators for application state management | Other State Management Features | . | . | Event Binding . | Universal Events | Gesture Events | . | Rendering Control . | Overview | if/else: Conditional Rendering | ForEach: Rendering of Repeated Content | . | . ArkTS Basics . ",
    "url": "/application-development/basic-concepts/introduction-to-arkts.html",
    
    "relUrl": "/application-development/basic-concepts/introduction-to-arkts.html"
  },"97": {
    "doc": "Introduction to Oniro",
    "title": "What is Oniro?",
    "content": "Oniro is an open-source, vendor-neutral Operating System (OS) managed by the Eclipse Foundation. It is built upon the foundational layers of OpenHarmony, an open-source project incubated and operated by the OpenAtom Foundation. OpenHarmony is known for its distributed OS features that cater to a wide range of smart devices, regardless of their size. Oniro extends OpenHarmony code base with add-ons for the European and Global markets, such as ReactNative support, Eclipse Theia based IDE, Servo web engine, and more that are coming. Text from: here . ",
    "url": "/introduction-to-oniro/introduction-to-oniro.html#what-is-oniro",
    
    "relUrl": "/introduction-to-oniro/introduction-to-oniro.html#what-is-oniro"
  },"98": {
    "doc": "Introduction to Oniro",
    "title": "Oniro Core",
    "content": "At its core, Oniro prioritizes seamless interoperability, modularization, and a visually appealing user interface. These priorities are realized through an array of enhancements, encompassing application frameworks like React Native, system-level OS components such as Servo Web Engine, and a comprehensive toolchain that ensures intellectual property compliance and licensing. This adaptable platform provides robust support for a broad range of global technologies and applications spanning various industries, including Consumer Electronics, Home Appliances, Industrial IoT devices, Smart Home, and Multimedia. Text from: here . ",
    "url": "/introduction-to-oniro/introduction-to-oniro.html#oniro-core",
    
    "relUrl": "/introduction-to-oniro/introduction-to-oniro.html#oniro-core"
  },"99": {
    "doc": "Introduction to Oniro",
    "title": "Introduction to Oniro",
    "content": " ",
    "url": "/introduction-to-oniro/introduction-to-oniro.html",
    
    "relUrl": "/introduction-to-oniro/introduction-to-oniro.html"
  },"100": {
    "doc": "Language Support",
    "title": "Language Support",
    "content": "Oniro IDE is built using Theia, which is heavily influenced by VS Code. The languages supported by the IDE are all those supported by VS Code. Examples of such are: . | Python | C/C++ | C# | . | Go | Java | JavaScript | . The Language Features are also shared with those in VS Code: . | Syntax highlighting and bracket matching | Smart completions | Linting and corrections | Code navigation | Debugging | Refactoring | . ",
    "url": "/device-development/oniro-ide/language-support.html",
    
    "relUrl": "/device-development/oniro-ide/language-support.html"
  },"101": {
    "doc": "Link Decorator",
    "title": "@Link Decorator",
    "content": "An @Link decorated variable creates two-way synchronization with a variable of its parent component. NOTE . This decorator can be used in ArkTS widgets since API version 9. ",
    "url": "/application-development/state-management-decorators/link-decorator.html#link-decorator",
    
    "relUrl": "/application-development/state-management-decorators/link-decorator.html#link-decorator"
  },"102": {
    "doc": "Link Decorator",
    "title": "Feature and Constraint",
    "content": ". | An @Link decorated variable in a child component shares the same value with a variable in its parent component. | The @Link decorator cannot be used in custom components decorated by @Entry. | . ",
    "url": "/application-development/state-management-decorators/link-decorator.html#feature-and-constraint",
    
    "relUrl": "/application-development/state-management-decorators/link-decorator.html#feature-and-constraint"
  },"103": {
    "doc": "Link Decorator",
    "title": "Usage Scenarios",
    "content": "Example for @Link with Simple and Class Types . In the following example, after Parent View: Set yellowButton and Parent View: Set GreenButton of the parent component ShufflingContainer are clicked, the change in the parent component is synchronized to the child components. | After buttons of the child components GreenButton and YellowButton are clicked, the child components (@Link decorated variables) change accordingly. Due to the two-way synchronization relationship between @Link and @State, the changes are synchronized to the parent component. | When a button in the parent component ShufflingContainer is clicked, the parent component (@State decorated variable) changes, and the changes are synchronized to the child components, which are then updated accordingly. | . class GreenButtonState { width: number = 0; constructor(width: number) { this.width = width; } } @Component struct GreenButton { @Link greenButtonState: GreenButtonState; build() { Button('Green Button') .width(this.greenButtonState.width) .height(40) .backgroundColor('#64bb5c') .fontColor('#FFFFFF, 90%') .onClick(() =&gt; { if (this.greenButtonState.width &lt; 700) { // Update the attribute of the class. The change can be observed and synchronized back to the parent component. this.greenButtonState.width += 60; } else { // Update the class. The change can be observed and synchronized back to the parent component. this.greenButtonState = new GreenButtonState(180); } }) } } @Component struct YellowButton { @Link yellowButtonState: number; build() { Button('Yellow Button') .width(this.yellowButtonState) .height(40) .backgroundColor('#f7ce00') .fontColor('#FFFFFF, 90%') .onClick(() =&gt; { // The change of the decorated variable of a simple type in the child component can be synchronized back to the parent component. this.yellowButtonState += 40.0; }) } } @Entry @Component struct ShufflingContainer { @State greenButtonState: GreenButtonState = new GreenButtonState(180); @State yellowButtonProp: number = 180; build() { Column() { Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center }) { // Simple type @Link in the child component synchronized from @State in the parent component. Button('Parent View: Set yellowButton') .width(312) .height(40) .margin(12) .fontColor('#FFFFFF, 90%') .onClick(() =&gt; { this.yellowButtonProp = (this.yellowButtonProp &lt; 700) ? this.yellowButtonProp + 40 : 100; }) // Class type @Link in the child component synchronized from @State in the parent component. Button('Parent View: Set GreenButton') .width(312) .height(40) .margin(12) .fontColor('#FFFFFF, 90%') .onClick(() =&gt; { this.greenButtonState.width = (this.greenButtonState.width &lt; 700) ? this.greenButtonState.width + 100 : 100; }) // Initialize the class type @Link. GreenButton({ greenButtonState: $greenButtonState }).margin(12) // Initialize the simple type @Link. YellowButton({ yellowButtonState: $yellowButtonProp }).margin(12) } } } } . Array Type @Link . The ArkUI framework can observe the addition, deletion, and replacement of array items. It should be noted that, in the following example, the type of the @Link and @State decorated variables is the same: number[]. It is not allowed to define the @Link decorated variable in the child component as type number (@Link item: number), and create child components for each array item in the @State decorated array in the parent component. @Component struct Child { @Link items: number[]; // Link array for bidirectional synchronization build() { Column({ space: 10 }) { Button(`Button1: push`).onClick(() =&gt; { // Add a new element to the array, synchronized back to the parent this.items.push(this.items.length + 1); }) .width('80%') .height(40) Button(`Button2: replace whole item`).onClick(() =&gt; { // Replace the entire array, synchronized back to the parent this.items = [100, 200, 300]; }) .width('80%') .height(40) } .margin(10) } } @Entry @Component struct Parent { @State arr: number[] = [1, 2, 3]; // State array for synchronization build() { Column() { Child({ items: $arr }) // Initialize Child with @Link to parent state array ForEach(this.arr, (item: number) =&gt; { Row() { Text(`${item}`) // Display each item in the array .fontColor('#d7072858') .height(40) } .margin(10) .width('80%') .justifyContent(FlexAlign.Center) .backgroundColor('#1e000000') .borderRadius(20) }, (item: number) =&gt; item.toString() ) } .width('100%') } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/link-decorator.html#usage-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/link-decorator.html#usage-scenarios"
  },"104": {
    "doc": "Link Decorator",
    "title": "Link Decorator",
    "content": " ",
    "url": "/application-development/state-management-decorators/link-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/link-decorator.html"
  },"105": {
    "doc": "LocalStorage",
    "title": "LocalStorage: UI State Storage",
    "content": "LocalStorage provides storage for the page-level UI state. The parameters of the LocalStorage type accepted through the @Entry decorator share the same LocalStorage instance on the page. LocalStorage also allows for state sharing between pages with UIAbility instances. This topic describes only the LocalStorage application scenarios and related decorators: @LocalStorageProp and @LocalStorageLink. NOTE . LocalStorage is supported since API version 9. ",
    "url": "/application-development/state-management-decorators/localstorage.html#localstorage-ui-state-storage",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html#localstorage-ui-state-storage"
  },"106": {
    "doc": "LocalStorage",
    "title": "Overview",
    "content": "LocalStorage is an in-memory “database” that ArkTS provides for storing state variables required to build pages of the application UI. | An application can create multiple LocalStorage instances. These instances can be shared on a page or, by using the GetShared API, across pages in a UIAbility instance. | The root node of a component tree, that is, the @Component decorated by @Entry, can be assigned to a LocalStorage instance. All child instances of this custom component automatically gain access to the same LocalStorage instance. | An @Component decorated component has access to at most one LocalStorage instance and to AppStorage. A component not decorated with @Entry cannot be assigned a LocalStorage instance. It can only accept a LocalStorage instance passed from its parent component through @Entry. A LocalStorage instance can be assigned to multiple components in the component tree. | All attributes in LocalStorage are mutable. | . The application determines the lifecycle of a LocalStorage object. The JS Engine will garbage collect a LocalStorage object when the application releases the last reference to it, which includes deleting the last custom component. LocalStorage provides two decorators based on the synchronization type of the component decorated with @Component: . | @LocalStorageProp: creates a one-way data synchronization with the named attribute in LocalStorage. | @LocalStorageLink: creates a two-way data synchronization with the named attribute in LocalStorage. | . ",
    "url": "/application-development/state-management-decorators/localstorage.html#overview",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html#overview"
  },"107": {
    "doc": "LocalStorage",
    "title": "@LocalStorageProp",
    "content": "As mentioned above, if you want to establish a binding between LocalStorage and a custom component, you need to use the @LocalStorageProp and @LocalStorageLink decorators. Specially, use @LocalStorageProp(key) or @LocalStorageLink(key) to decorate variables in the component, where key identifies the attribute in LocalStorage. When a custom component is initialized, the @LocalStorageProp(key)/@LocalStorageLink(key) decorated variable is initialized with the value of the attribute with the given key in LocalStorage. Local initialization is mandatory. If an attribute with the given key is missing from LocalStorage, it will be added with the stated initializing value. (Whether the attribute with the given key exists in LocalStorage depends on the application logic.) . NOTE . This decorator can be used in ArkTS widgets since API version 9. By decorating a variable with @LocalStorageProp(key), a one-way data synchronization is established from the attribute with the given key in LocalStorage to the variable. This means that, local changes (if any) will not be synchronized to LocalStorage, and an update to the attribute with the given key in LocalStorage – for example, a change made with the **set ** API – will overwrite local changes. ",
    "url": "/application-development/state-management-decorators/localstorage.html#localstorageprop",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html#localstorageprop"
  },"108": {
    "doc": "LocalStorage",
    "title": "@LocalStorageLink",
    "content": "@LocalStorageLink is required if you need to synchronize the changes of the state variables in a custom component back to LocalStorage. @LocalStorageLink(key) creates a two-way data synchronization with the attribute with the given key in LocalStorage. | If a local change occurs, it is synchronized to LocalStorage. | Changes in LocalStorage are synchronized to all attributes with the given key, including one-way bound variables (@LocalStorageProp decorated variables and one-way bound variables created through @Prop) and two-way bound variables (@LocalStorageLink decorated variables and two-way bound variables created through @Link). | . ",
    "url": "/application-development/state-management-decorators/localstorage.html#localstoragelink",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html#localstoragelink"
  },"109": {
    "doc": "LocalStorage",
    "title": "Use Scenarios",
    "content": "Example of Using LocalStorage in Application Logic . let para: Record&lt;string,number&gt; = { 'PropA': 47 }; let storage: LocalStorage = new LocalStorage(para); // Create an instance and initialize it with the given object. let propA: number | undefined = storage.get('PropA') // propA == 47 let link1: SubscribedAbstractProperty&lt;number&gt; = storage.link('PropA'); // link1.get() == 47 let link2: SubscribedAbstractProperty&lt;number&gt; = storage.link('PropA'); // link2.get() == 47 let prop: SubscribedAbstractProperty&lt;number&gt; = storage.prop('PropA'); // prop.get() == 47 link1.set(48); // two-way sync: link1.get() == link2.get() == prop.get() == 48 prop.set(1); // one-way sync: prop.get() == 1; but link1.get() == link2.get() == 48 link1.set(49); // two-way sync: link1.get() == link2.get() == prop.get() == 49 . Example for Using LocalStorage Inside the UI . The two decorators @LocalStorageProp and @LocalStorageLink can work together to obtain the state variable stored in a LocalStorage instance in the UI component. This example uses @LocalStorageLink to show how to: . | Use the build function to create a LocalStorage instance named storage. | Use the @Entry decorator to add storage to the top-level component CompA. | Use @LocalStorageLink to create a two-way data synchronization with the given attribute in LocalStorage. | . class PropB { code: number; constructor(code: number) { this.code = code; } } // Create a new instance and initialize it with the given object. let para: Record&lt;string, number&gt; = { 'PropA': 47 }; let storage: LocalStorage = new LocalStorage(para); storage.setOrCreate('PropB', new PropB(50)); @Component struct Child { // @LocalStorageLink creates a two-way data synchronization with the PropA attribute in LocalStorage. @LocalStorageLink('PropA') childLinkNumber: number = 1; // @LocalStorageLink creates a two-way data synchronization with the PropB attribute in LocalStorage. @LocalStorageLink('PropB') childLinkObject: PropB = new PropB(0); build() { Column() { Button(`Child from LocalStorage ${this.childLinkNumber}`) // The changes will be synchronized to PropA in LocalStorage and with Parent.parentLinkNumber.onClick(() =&gt; { this.childLinkNumber += 1; }) Button(`Child from LocalStorage ${this.childLinkObject.code}`) // The changes will be synchronized to PropB in LocalStorage and with Parent.parentLinkObject.code.onClick(() =&gt; { this.childLinkObject.code += 1; }) } } } // Make LocalStorage accessible from the @Component decorated component. @Entry(storage) @Component struct CompA { // @LocalStorageLink creates a two-way data synchronization with the PropA attribute in LocalStorage. @LocalStorageLink('PropA') parentLinkNumber: number = 1; // @LocalStorageLink creates a two-way data synchronization with the PropB attribute in LocalStorage. @LocalStorageLink('PropB') parentLinkObject: PropB = new PropB(0); build() { Column({ space: 15 }) { Button(`Parent from LocalStorage ${this.parentLinkNumber}`) // The initial value from LocalStorage will be 47, because PropA has been initialized.onClick(() =&gt; { this.parentLinkNumber += 1; }) Button(`Parent from LocalStorage ${this.parentLinkObject.code}`) // The initial value from LocalStorage will be 50, because PropB has been initialized.onClick(() =&gt; { this.parentLinkObject.code += 1; }) // @The @Component decorated child component automatically obtains access to the CompA LocalStorage instance. Child() } } } . Simple Example of Using @LocalStorageProp with LocalStorage . In this example, the CompA and Child components create local data that is one-way synchronized with the PropA attribute in the LocalStorage instance storage. | The change of this.storProp1 in CompA takes effect only in CompA and is not synchronized to storage. | In the Child component, the value of storageProp2 bound to Text is still 47. | . // Create a new instance and initialize it with the given object. let para: Record&lt;string, number&gt; = { 'PropA': 47 }; let storage: LocalStorage = new LocalStorage(para); // Make LocalStorage accessible from the @Component decorated component. @Entry(storage) @Component struct CompA { // @LocalStorageProp creates a one-way data synchronization with the PropA attribute in LocalStorage. @LocalStorageProp('PropA') storageProp1: number = 1; build() { Column({ space: 15 }) { // The initial value is 47. After the button is clicked, the value is incremented by 1. The change takes effect only in storageProp1 in the current component and is not synchronized to LocalStorage. Button(`Parent from LocalStorage ${this.storageProp1}`) .onClick(() =&gt; { this.storageProp1 += 1 }) Child() } } } @Component struct Child { // @LocalStorageProp creates a one-way data synchronization with the PropA attribute in LocalStorage. @LocalStorageProp('PropA') storageProp2: number = 2; build() { Column({ space: 15 }) { // When CompA changes, the current storageProp2 does not change, and 47 is displayed. Text(`Parent from LocalStorage ${this.storageProp2}`) } } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/localstorage.html#use-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html#use-scenarios"
  },"110": {
    "doc": "LocalStorage",
    "title": "LocalStorage",
    "content": " ",
    "url": "/application-development/state-management-decorators/localstorage.html",
    
    "relUrl": "/application-development/state-management-decorators/localstorage.html"
  },"111": {
    "doc": "Observed and ObjectLink Decorators",
    "title": "@Observed and @ObjectLink Decorators",
    "content": "@ObjectLink and @Observed class decorators are used for two-way data synchronization in scenarios involving nested objects or arrays, making up for the limitation that other decorators can only observe changes in one layer. NOTE . These two decorators can be used in ArkTS widgets since API version 9. ",
    "url": "/application-development/state-management-decorators/observed-objectlink-decorator.html#observed-and-objectlink-decorators",
    
    "relUrl": "/application-development/state-management-decorators/observed-objectlink-decorator.html#observed-and-objectlink-decorators"
  },"112": {
    "doc": "Observed and ObjectLink Decorators",
    "title": "Features",
    "content": ". | @Observed is used to mark a class so that its created instances can observe property changes, mainly used in nested class scenarios. | @ObjectLink decorates the state variables in the child component, receives the instance of the class decorated with @Observed, and establishes a two-way data binding with the corresponding state variable in the parent component. | . ",
    "url": "/application-development/state-management-decorators/observed-objectlink-decorator.html#features",
    
    "relUrl": "/application-development/state-management-decorators/observed-objectlink-decorator.html#features"
  },"113": {
    "doc": "Observed and ObjectLink Decorators",
    "title": "Constraints",
    "content": ". | Using @Observed to decorate a class changes the original prototype chain of the class. Using @Observed and other class decorators to decorate the same class may cause problems. | The @ObjectLink decorator cannot be used in custom components decorated by @Entry. | Value assignment is not allowed for the @ObjectLink decorated variable. To assign a value, use @Prop instead. | . ",
    "url": "/application-development/state-management-decorators/observed-objectlink-decorator.html#constraints",
    
    "relUrl": "/application-development/state-management-decorators/observed-objectlink-decorator.html#constraints"
  },"114": {
    "doc": "Observed and ObjectLink Decorators",
    "title": "Usage Scenarios",
    "content": "Nested Object . NOTE . NextID is used to generate a unique, persistent key for each array item during ForEach rendering, so as to identify the corresponding component. // objectLinkNestedObjects.ets let NextID: number = 1; @Observed class Bag { public id: number; public size: number; constructor(size: number) { this.id = NextID++; this.size = size; } } @Observed class User { public bag: Bag; constructor(bag: Bag) { this.bag = bag; } } @Observed class Book { public bookName: BookName; constructor(bookName: BookName) { this.bookName = bookName; } } @Observed class BookName extends Bag { public nameSize: number; constructor(nameSize: number) { // Invoke the parent class method to process nameSize. super(nameSize); this.nameSize = nameSize; } } @Component struct ViewA { label: string = 'ViewA'; @ObjectLink bag: Bag; build() { Column() { Text(`ViewA [${this.label}] this.bag.size = ${this.bag.size}`) .fontColor('#ffffffff') .backgroundColor('#ff3d9dba') .width(320) .height(50) .borderRadius(25) .margin(10) .textAlign(TextAlign.Center) Button(`ViewA: this.bag.size add 1`) .width(320) .backgroundColor('#ff17a98d') .margin(10) .onClick(() =&gt; { this.bag.size += 1; }) } } } @Component struct ViewC { label: string = 'ViewC1'; @ObjectLink bookName: BookName; build() { Row() { Column() { Text(`ViewC [${this.label}] this.bookName.size = ${this.bookName.size}`) .fontColor('#ffffffff') .backgroundColor('#ff3d9dba') .width(320) .height(50) .borderRadius(25) .margin(10) .textAlign(TextAlign.Center) Button(`ViewC: this.bookName.size add 1`) .width(320) .backgroundColor('#ff17a98d') .margin(10) .onClick(() =&gt; { this.bookName.size += 1; console.log('this.bookName.size:' + this.bookName.size) }) } .width(320) } } } @Entry @Component struct ViewB { @State user: User = new User(new Bag(0)); @State child: Book = new Book(new BookName(0)); build() { Column() { ViewA({ label: 'ViewA #1', bag: this.user.bag }) .width(320) ViewC({ label: 'ViewC #3', bookName: this.child.bookName }) .width(320) Button(`ViewB: this.child.bookName.size add 10`) .width(320) .backgroundColor('#ff17a98d') .margin(10) .onClick(() =&gt; { this.child.bookName.size += 10 console.log('this.child.bookName.size:' + this.child.bookName.size) }) Button(`ViewB: this.user.bag = new Bag(10)`) .width(320) .backgroundColor('#ff17a98d') .margin(10) .onClick(() =&gt; { this.user.bag = new Bag(10); }) Button(`ViewB: this.user = new User(new Bag(20))`) .width(320) .backgroundColor('#ff17a98d') .margin(10) .onClick(() =&gt; { this.user = new User(new Bag(20)); }) } } } . The @Observed decorated BookName class can observe changes in the attributes inherited from the base class. Event handles in ViewB: . | this.user.bag = new Bag(10) and this.user = new User(new Bag(20)): Change to the @State decorated variable size and its attributes. | this.child.bookName.size += …: Change at the second layer. Though @State cannot observe changes at the second layer, the change of an attribute of @Observed decorated Bag, which is attribute size in this example, can be observed by @ObjectLink. | . Event handle in ViewC: . | this.bookName.size += 1: A change to the @ObjectLink decorated variable size causes the button label to be updated. Unlike @Prop, @ObjectLink does not have a copy of its source. Instead, @ObjectLink creates a reference to its source. | The @ObjectLink decorated variable is read-only. Assigning this.bookName = new bookName(…) is not allowed. Once value assignment occurs, the reference to the data source is reset and the synchronization is interrupted. | . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/observed-objectlink-decorator.html#usage-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/observed-objectlink-decorator.html#usage-scenarios"
  },"115": {
    "doc": "Observed and ObjectLink Decorators",
    "title": "Observed and ObjectLink Decorators",
    "content": " ",
    "url": "/application-development/state-management-decorators/observed-objectlink-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/observed-objectlink-decorator.html"
  },"116": {
    "doc": "Introduction to OHPM",
    "title": "Introduction to OHPM",
    "content": "OHPM (OpenHarmony Package Manager) is a package management system designed for OpenHarmony, providing access to third-party libraries and tools that enhance development efficiency and functionality within the OpenHarmony ecosystem. (Think of it as NPM in openharmony) . OpenHarmony Third Party Repository . Some examples of library： . | ohos_axios: A promise-based network request library that can run on Node.js and browsers, and is adapted for OpenHarmony. | socket.io: A library for implementing low-latency, bidirectional communication between clients and servers, supporting WebSocket protocol. | mars: A cross-platform network component library that provides solutions for long and short network connections. | httpclient: An efficient HTTP client for OpenHarmony that supports various protocols and optimizes network transmission. | . ",
    "url": "/application-development/environment-setup-config/ohpm.html",
    
    "relUrl": "/application-development/environment-setup-config/ohpm.html"
  },"117": {
    "doc": "Oniro Architecture",
    "title": "Oniro Architecture",
    "content": "Architecture . The Eclipse Oniro architecture builds on the solid foundations of OpenHarmony, enhancing and expanding its capabilities. All system enhancements are rigorously managed by an advanced IP toolchain to ensure compliance throughout the development process. Within this framework: . | React Native extends the usability of existing applications and ecosystems on top of OpenHarmony, enabling seamless integration across platforms. | Eclipse Kanto expands Oniro’s ecosystem adaptability and scalability by empowering edge devices with advanced IoT functionalities, including seamless cloud connectivity and flexible device management. | The incorporation of the Rust language, particularly for the Servo web engine, bolsters the overall system’s safety and security. | Eclipse Theia enhances the development workflow, simplifying application creation within the ecosystem. | libvsync improves the performance and reliability of applications that require precise coordination across multiple processes. Future enhancements will include the integration of NearLink, offering an alternative to Wi-Fi and Bluetooth with lower latency and improved connectivity, particularly suited for automotive and industrial environments. | . Text from here . Features . Hardware collaboration and resource sharing This feature is implemented through the following modules: . | DSoftBus DSoftBus is a unified base for seamless interconnection among devices. It powers OpenHarmony with distributed communication capabilities to quickly discover and connect devices, and efficiently transmit data. | Distributed data management Distributed data management leverages DSoftBus to manage application data and user data distributed on different devices. Under such management, user data is no longer bound to a single physical device, and service logic is decoupled from storage. As your applications are running across devices, their data is seamlessly transmitted from one device to another, creating a foundation for a user experience that is smooth and consistent. | Distributed Scheduler Distributed Scheduler is designed based on technical features such as DSoftBus, distributed data management, and distributed profile. It builds a unified distributed service management mechanism (including service discovery, synchronization, registration, and invocation), and supports remote startup, remote invocation, binding/unbinding, and migration of applications across devices. This way, your application can select the most suitable device to perform distributed tasks based on the capabilities, locations, running status, and resource usage of different devices, as well as user habits and intentions. | Device virtualization A distributed device virtualization platform enables cross-device resource convergence, device management, and data processing so that virtual peripherals can function as capability extensions of smartphones to form a Super Device. | . One-time development for multi-device deployment . OpenHarmony provides you with the application, ability, and UI frameworks. With these frameworks, you can develop your applications once, and then flexibly deploy them across a broad range of different devices. One-time development for multi-device deployment . Consistent APIs ensure the operational compatibility of applications across devices. | Adaptation of device capabilities (including CPU, memory, peripheral, and software resources) can be previewed. | Resources can be scheduled based on the compatibility between applications and the software platform. | . A unified OS for flexible deployment . OpenHarmony enables hardware resources to be scaled with its component-based and small-scale designs. It can be deployed on demand for a diverse range of devices, including ARM, RISC-V, and x86 architectures, and providing RAM volumes ranging from hundreds of KiB to GiB. Text from here . Note: need verify the words used in this text like ‘OpenHarmony’ since we want to emphasize Oniro . System Types . OpenHarmony supports the following system types: . | Mini system A mini system fits into devices that come with Micro Controller Units (MCUs), such as Arm Cortex-M and 32-bit RISC-V processors, and memory greater than or equal to 128 KiB. This system provides multiple lightweight network protocols, a lightweight graphics framework, and a wide range of read/write components with the IoT bus. Typical products include connection modules, sensors, and wearables for smart home. | Small system A small system runs on devices whose memory is greater than or equal to 1 MiB and that are equipped with application processors such as Arm Cortex-A. This system provides higher security capabilities, standard graphics frameworks, and video encoding and decoding capabilities. Typical products include smart home IP cameras, electronic cat eyes, and routers, and event data recorders (EDRs) for easy travel. | Standard system A standard system runs on devices whose memory is greater than or equal to 128 MiB and that are equipped with application processors such as Arm Cortex-A. This system provides a complete application framework supporting the enhanced interaction, 3D GPU, hardware composer, diverse components, and rich animations. This system applies to high-end refrigerator displays. | . Text from here . Note: need verify the words used in this text like ‘OpenHarmony’ since we want to emphasize Oniro . Source from OpenHarmony docs used LICENSE CC BY 4.0 You can find legal notice about such info here . ",
    "url": "/introduction-to-oniro/oniro-architecture.html",
    
    "relUrl": "/introduction-to-oniro/oniro-architecture.html"
  },"118": {
    "doc": "$$ Syntax",
    "title": "$$ Syntax: Two-Way Synchronization of Built-in Components",
    "content": "The $$ operator provides a TypeScript variable by-reference to a built-in component so that the variable value and the internal state of that component are kept in sync. What the internal state is depends on the component. For example, for the &lt;TextInput&gt; component, it is the text parameter. ",
    "url": "/application-development/state-management-decorators/operator.html#-syntax-two-way-synchronization-of-built-in-components",
    
    "relUrl": "/application-development/state-management-decorators/operator.html#-syntax-two-way-synchronization-of-built-in-components"
  },"119": {
    "doc": "$$ Syntax",
    "title": "Example",
    "content": "This example uses the text parameter of the &lt;TextInput&gt; component. // xxx.ets @Entry @Component struct TextInputExample { @State text: string = '' controller: TextInputController = new TextInputController() build() { Column({ space: 20 }) { Text(this.text) TextInput({ text: $$this.text, placeholder: 'input your word...', controller: this.controller }) .placeholderColor(Color.Grey) .placeholderFont({ size: 14, weight: 400 }) .caretColor(Color.Blue) .width(300) }.width('100%').height('100%').justifyContent(FlexAlign.Center) } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/operator.html#example",
    
    "relUrl": "/application-development/state-management-decorators/operator.html#example"
  },"120": {
    "doc": "$$ Syntax",
    "title": "$$ Syntax",
    "content": " ",
    "url": "/application-development/state-management-decorators/operator.html",
    
    "relUrl": "/application-development/state-management-decorators/operator.html"
  },"121": {
    "doc": "Implementing Page Redirection",
    "title": "Implementing Page Redirection",
    "content": "You can achieve page navigation using the page router, which locates the target page based on its URL. To implement this, first import the router module and follow the steps below. To deliver better transition effects, use Navigation(Recommended). Redirection from the first page to the second page . In the Index.ets file of the first page, bind the onClick event to the Next button, allowing users to navigate to the second page when clicked. The sample code in Index.ets is shown below: . // Index.ets // Import the router module. import router from '@ohos.router'; import { BusinessError } from '@ohos.base'; @Entry @Component struct Index { @State message: string = 'Hello World'; build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) // Add a button to respond to user clicks. Button() { Text('Next') .fontSize(30) .fontWeight(FontWeight.Bold) } .type(ButtonType.Capsule) .margin({ top: 20 }) .backgroundColor('#0D9FFB') .width('40%') .height('5%') // Bind the onClick event to the Next button so that clicking the button redirects the user to the second page.onClick(() =&gt; { console.info(`Succeeded in clicking the 'Next' button.`) // Go to the second page. router.pushUrl({ url: 'pages/SecondPage' }).then(() =&gt; { console.info('Succeeded in jumping to the second page.') }).catch((err: BusinessError) =&gt; { console.error(`Failed to jump to the second page.Code is ${err.code}, message is ${err.message}`) }) }) } .width('100%') } .height('100%') } } . Click the Next button now and page will redirect to the SecondPage. You can also observe the printed information in console as well. Redirection from the second page to the first page . In the SecondPage.ets file of the second page, bind the onClick event to the Back button, enabling users to navigate back to the first page when clicked. The sample code in SecondPage.ets is shown below: . // SecondPage.ets // Import the router module. import router from '@ohos.router'; import { BusinessError } from '@ohos.base'; @Entry @Component struct SecondPage { @State message: string = 'Hi there'; build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) Button() { Text('Back') .fontSize(25) .fontWeight(FontWeight.Bold) } .type(ButtonType.Capsule) .margin({ top: 20 }) .backgroundColor('#0D9FFB') .width('40%') .height('5%') // Bind the onClick event to the Back button so that clicking the button redirects the user back to the first page.onClick(() =&gt; { console.info(`Succeeded in clicking the 'Back' button.`) try { // Return to the first page. router.back() console.info('Succeeded in returning to the first page.') } catch (err) { let code = (err as BusinessError).code; let message = (err as BusinessError).message; console.error(`Failed to return to the first page.Code is ${code}, message is ${message}`) } }) } .width('100%') } .height('100%') } } . Click the Back button on the page or the triangle icon on the Previewer, the page will redirect back to the Index. You can also observe the printed information in console as well. ",
    "url": "/application-development/create-first-eclipse-oniro-app/page-redirect.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/page-redirect.html"
  },"122": {
    "doc": "PersistentStorage",
    "title": "PersistentStorage",
    "content": "During application development, you may want selected attributes to persist even when the application is closed. In this case, you’ll need PersistentStorage. PersistentStorage is an optional singleton object within an application. Its purpose is to persist selected AppStorage attributes so that their values are the same upon application re-start as they were when the application was closed. ",
    "url": "/application-development/state-management-decorators/persistentstorage.html",
    
    "relUrl": "/application-development/state-management-decorators/persistentstorage.html"
  },"123": {
    "doc": "PersistentStorage",
    "title": "Overview",
    "content": "PersistentStorage retains the selected AppStorage attributes on the device. The application uses the API to determine which AppStorage attributes should be persisted with PersistentStorage. The UI and business logic do not directly access attributes in PersistentStorage. All attribute access is to AppStorage. Changes in AppStorage are automatically synchronized to PersistentStorage. PersistentStorage creates a two-way synchronization with attributes in AppStorage. A frequently used API function is to access AppStorage through PersistentStorage. Additional API functions include managing persisted attributes. The business logic always obtains or sets attributes through AppStorage. ",
    "url": "/application-development/state-management-decorators/persistentstorage.html#overview",
    
    "relUrl": "/application-development/state-management-decorators/persistentstorage.html#overview"
  },"124": {
    "doc": "PersistentStorage",
    "title": "Constraints",
    "content": "PersistentStorage accepts the following types and values: . | Primitive types such as number, string, boolean, and enum. | Objects that can be reconstructed by JSON.stringify() and JSON.parse(). In other words, built-in types such as Date, Map, and Set, as well as object attribute methods, are not supported. | . PersistentStorage does not accept the following types and values: . | Nested objects (object arrays and object attributes), because the framework cannot detect the value changes of nested objects (including arrays) in AppStorage. | undefined and null. | . Data persistence is an operation that takes time. Applications should avoid the following situations: . | Persistence of large data sets . | Persistence of variables that change frequently . | . It is recommended that the persistent variables of PersistentStorage be less than 2 KB. As PersistentStorage flushes data synchronously, a large amount of persistent data may result in simultaneous time-consuming read and write operations in the UI thread, affecting UI rendering performance. If you need to store a large amount of data, consider using the database API. PersistentStorage is associated with UI instances. Data persistence can succeed only when a UI instance has been initialized (that is, when the callback passed in by loadContent is called). // EntryAbility.ets onWindowStageCreate(windowStage: window.WindowStage): void { windowStage.loadContent('pages/Index', (err) =&gt; { if (err.code) { return; } PersistentStorage.persistProp('aProp', 47); }); } . ",
    "url": "/application-development/state-management-decorators/persistentstorage.html#constraints",
    
    "relUrl": "/application-development/state-management-decorators/persistentstorage.html#constraints"
  },"125": {
    "doc": "PersistentStorage",
    "title": "Use Scenarios",
    "content": "Accessing PersistentStorage Initialized Attribute from AppStorage . | Initialize the PersistentStorage instance. PersistentStorage.persistProp('aProp', 47); . | Obtain the corresponding attribute from AppStorage. AppStorage.get&lt;number&gt;('aProp'); // returns 47 . Alternatively, apply local definition within the component: . @StorageLink('aProp') aProp: number = 48; . | . The complete code is as follows: . PersistentStorage.persistProp('aProp', 47); @Entry @Component struct Index { @State message: string = 'Hello World' @StorageLink('aProp') aProp: number = 48 build() { Row() { Column() { Text(this.message) // The current result is saved when the application exits. After the restart, the last saved result is displayed. Text(`${this.aProp}`) .onClick(() =&gt; { this.aProp += 1; }) } } } } . | First running after fresh application installation: . | persistProp is called to initialize PersistentStorage. A search for the aProp attribute in PersistentStorage returns no result, because the application has just been installed. | A search for the attribute aProp in AppStorage still returns no result. | Create the aProp attribute of the number type in AppStorge and initialize it with the value 47. | PersistentStorage writes the aProp attribute and its value 47 to the local device. The value of aProp in AppStorage and its subsequent changes are persisted. | In the &lt;Index&gt; component, create the state variable @StorageLink(‘aProp’) aProp, which creates a two-way synchronization with the aProp attribute in AppStorage. During the creation, the search in AppStorage for the aProp attribute is successful, and therefore, the state variable is initialized with the value 47 found in AppStorage. | . | After a click event is triggered: . | The state variable @StorageLink(‘aProp’) aProp is updated, triggering the &lt;Text&gt; component to be re-rendered. | The two-way synchronization between the @StorageLink decorated variable and AppStorage results in the change of the @StorageLink(‘aProp’) aProp being synchronized back to AppStorage. | The change of the aProp attribute in AppStorage triggers any other one-way or two-way bound variables to be updated. (In this example, there are no such other variables.) | Because the attribute corresponding to aProp has been persisted, the change of the aProp attribute in AppStorage triggers PersistentStorage to write the attribute and its new value to the device. | . | Subsequent application running: . | PersistentStorage.persistProp(‘aProp’, 47) is called. A search for the aProp attribute in PersistentStorage succeeds. | The attribute is added to AppStorage with the value found in PersistentStorage. | In the &lt;Index&gt; component, the value of the @StorageLink decorated aProp attribute is the value written by PersistentStorage to AppStorage, that is, the value stored when the application was closed last time. | . | . Accessing an Attribute in AppStorage Before PersistentStorage . This example is an incorrect use. It is incorrect to use the API to access the attributes in AppStorage before calling PersistentStorage.persistProp or persistProps, because such a call sequence will result in loss of the attribute values used in the previous application run: . let aProp = AppStorage.setOrCreate('aProp', 47); PersistentStorage.persistProp('aProp', 48); . AppStorage.setOrCreate(‘aProp’, 47): The aProp attribute of the number type is created in AppStorage, and its value is set to the specified default value 47. aProp is a persisted attribute. Therefore, it is written back to PersistentStorage, and the value stored in PersistentStorage from the previous run is lost. PersistentStorage.persistProp(‘aProp’, 48): An attribute with the name aProp and value 47 – set through the API in AppStorage – is found in PersistentStorage. Accessing an Attribute in AppStorage After PersistentStorage . If you do not want to overwrite the values saved in PersistentStorage during the previous application run, make sure any access to attributes in AppStorage is made after a call to a PersistentStorage API. PersistentStorage.persistProp('aProp', 48); if (AppStorage.get('aProp') &gt; 50) { // If the value stored in PersistentStorage exceeds 50, set the value to 47. AppStorage.setOrCreate('aProp',47); } . After reading the data stored in PersistentStorage, the sample code checks whether the value of aProp is greater than 50 and, if it is, sets aProp to 47 through an API in AppStorage. ",
    "url": "/application-development/state-management-decorators/persistentstorage.html#use-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/persistentstorage.html#use-scenarios"
  },"126": {
    "doc": "Prop Decorator",
    "title": "@Prop Decorator",
    "content": "One-way synchronization is supported between an @Prop decorated variable a variable of its parent component. This means that, an @Prop decorated variable is mutable, and its changes will not be synchronized to the parent component. ",
    "url": "/application-development/state-management-decorators/prop-decorator.html#prop-decorator",
    
    "relUrl": "/application-development/state-management-decorators/prop-decorator.html#prop-decorator"
  },"127": {
    "doc": "Prop Decorator",
    "title": "Features",
    "content": "For the @Prop decorated variable of a child component, the change synchronization to the parent component is uni-directional. | An @Prop variable is allowed to be modified locally, but the change does not propagate back to its parent component. | Whenever the data source changes, the @Prop decorated variable gets updated, and any locally made changes are overwritten. In other words, the change is synchronized from the parent component to the (owning) child component, but not the other way around. | . ",
    "url": "/application-development/state-management-decorators/prop-decorator.html#features",
    
    "relUrl": "/application-development/state-management-decorators/prop-decorator.html#features"
  },"128": {
    "doc": "Prop Decorator",
    "title": "Restrictions",
    "content": ". | When decorating variables, @Prop makes a deep copy, during which all types, except primitive types, Map, Set, Date, and Array, will be lost. For example, for complex types provided by N-API, such as PixelMap, because they are partially implemented in the native code, complete data cannot be obtained through a deep copy in ArkTS. | The @Prop decorator cannot be used in custom components decorated by @Entry. | . ",
    "url": "/application-development/state-management-decorators/prop-decorator.html#restrictions",
    
    "relUrl": "/application-development/state-management-decorators/prop-decorator.html#restrictions"
  },"129": {
    "doc": "Prop Decorator",
    "title": "Use Scenarios",
    "content": "Simple Type Sync from @State of the Parent Component to @Prop of the Child Component . In this example, the @Prop decorated count variable in the CountDownComponent child component is initialized from the @State decorated countDownStartValue variable in the ParentComponent. When Try again is touched, the value of the count variable is modified, but the change remains within the CountDownComponent and does not affect the ParentComponent. Updating countDownStartValue in the ParentComponent will update the value of the @Prop decorated count. @Component struct CountDownComponent { @Prop count: number = 0; costOfOneAttempt: number = 1; build() { Column() { if (this.count &gt; 0) { Text(`You have ${this.count} Nuggets left`) } else { Text('Game over!') } // Changes to the @Prop decorated variables are not synchronized to the parent component. Button(`Try again`).onClick(() =&gt; { this.count -= this.costOfOneAttempt; }) } } } @Entry @Component struct ParentComponent { @State countDownStartValue: number = 10; build() { Column() { Text(`Grant ${this.countDownStartValue} nuggets to play.`) // Changes to the data source provided by the parent component are synchronized to the child component. Button(`+1 - Nuggets in New Game`).onClick(() =&gt; { this.countDownStartValue += 1; }) // Updating the parent component will also update the child component. Button(`-1 - Nuggets in New Game`).onClick(() =&gt; { this.countDownStartValue -= 1; }) CountDownComponent({ count: this.countDownStartValue, costOfOneAttempt: 2 }) } } } . The display is previewed as the following: . In the preceding example: . | On initial render, when the CountDownComponent child component is created, its @Prop decorated count variable is initialized from the @State decorated countDownStartValue variable in the ParentComponent. | When the “+1” or “-1” button is touched, the @State decorated countDownStartValue of the ParentComponent changes. This will cause the ParentComponent to re-render. At the minimum, the CountDownComponent will be updated because of the change in the count variable value. | Because of the change in the count variable value, the CountDownComponent child component will re-render. At a minimum, the if statement’s condition (this.counter&gt; 0) is evaluated, and the &lt;Text&gt; child component inside the if statement would be updated. | When Try again in the CountDownComponent child component is touched, the value of the count variable is modified, but the change remains within the child component and does not affect the countDownStartValue in the parent component. | Updating countDownStartValue will overwrite the local value changes of the @Prop decorated count in the CountDownComponent child component. | . Simple Type @Prop Synced from @State Array Item in Parent Component . The @State decorated array an array item in the parent component can be used as data source to initialize and update a @Prop decorated variable. In the following example, the @State decorated array arr in the parent component Index initializes the @Prop decorated value variable in the child component Child. @Component struct Child { @Prop value: number = 0; build() { Text(`${this.value}`) .fontSize(50) .onClick(() =&gt; { this.value++ }) } } @Entry @Component struct Index { @State arr: number[] = [1, 2, 3]; build() { Row() { Column() { Child({ value: this.arr[0] }) Child({ value: this.arr[1] }) Child({ value: this.arr[2] }) Divider().height(5) ForEach(this.arr, (item: number) =&gt; { Child({ value: item }) }, (item: string) =&gt; item.toString() ) Text('replace entire arr') .fontSize(50) .onClick(() =&gt; { // Both arrays contain item \"3\". this.arr = this.arr[0] == 1 ? [3, 4, 5] : [1, 2, 3]; }) } } } } . Initial render creates six instances of the Child component. Each @Prop decorated variable is initialized with a copy of an array item. The onclick event handler of the Child component changes the local variable value. Click 1 six times, 2 five times, and 3 four times on the page. The local values of all variables are then changed to 7. 7 7 7 ---- 7 7 7 . After replace entire arr is clicked, the following information is displayed: . 3 4 5 ---- 7 4 5 . | Changes made in the Child component are not synchronized to the parent component Index. Therefore, even if the values of the six instances of the Child component are 7, the value of this.arr in the Index component is still [1,2,3]. | After replace entire arr is clicked, if this.arr[0] == 1 is true, this.arr is set to [3, 4, 5]. | Because this.arr[0] has been changed, the Child({value: this.arr[0]}) component synchronizes the update of this.arr[0] to the instance’s @Prop decorated variable. The same happens for Child({value: this.arr[1]}) and Child({value: this.arr[2]}). | The change of this.arr causes ForEach to update: According to the diff algorithm, the array item with the ID 3 is retained in this update, array items with IDs 1 and 2 are deleted, and array items with IDs 4 and 5 are added. The array before and after the update is [1, 2, 3] and [3, 4, 5], respectively. This implies that the Child instance generated for item 3 is moved to the first place, but not updated. In this case, the component value corresponding to 3 is 7, and the final render result of ForEach is 7, 4, and 5. | . Class Object Type @Prop Synced from @State Class Object Property in Parent Component . In a library with one book and two readers, each reader can mark the book as read, and the marking does not affect the other reader. Technically speaking, local changes to the @Prop decorated book object do not sync back to the @State decorated book in the Library component. In this example, the @Observed decorator can be applied to the book class, but it is not mandatory. It is only needed for nested structures. class Book { public title: string; public pages: number; public readIt: boolean = false; constructor(title: string, pages: number) { this.title = title; this.pages = pages; } } @Component struct ReaderComp { @Prop book: Book = new Book(\"\", 0); build() { Row() { Text(this.book.title) Text(`...has${this.book.pages} pages!`) Text(`...${this.book.readIt ? \"I have read\" : 'I have not read it'}`) .onClick(() =&gt; this.book.readIt = true) } } } @Entry @Component struct Library { @State book: Book = new Book('100 secrets of C++', 765); build() { Column() { ReaderComp({ book: this.book }) ReaderComp({ book: this.book }) } } } . The display is previewed as the following: . ",
    "url": "/application-development/state-management-decorators/prop-decorator.html#use-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/prop-decorator.html#use-scenarios"
  },"130": {
    "doc": "Prop Decorator",
    "title": "Prop Decorator",
    "content": " ",
    "url": "/application-development/state-management-decorators/prop-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/prop-decorator.html"
  },"131": {
    "doc": "Provide and Consume Decorators",
    "title": "@Provide and @Consume Decorators",
    "content": "@Provide and @Consume are used for two-way data synchronization with descendant components when state data needs to be transferred between multiple levels. They do not involve passing a variable from component to component multiple times. | An @Provide decorated state variable exists in the ancestor component and is said to be “provided” to descendent components. | An @Consume decorated state variable is used in a descendent component. It is linked to (“consumes”) the provided state variable in its ancestor component. | . NOTE . Since API version 9, these two decorators are supported in ArkTS widgets. ",
    "url": "/application-development/state-management-decorators/provide-consume-decorator.html#provide-and-consume-decorators",
    
    "relUrl": "/application-development/state-management-decorators/provide-consume-decorator.html#provide-and-consume-decorators"
  },"132": {
    "doc": "Provide and Consume Decorators",
    "title": "Features",
    "content": ". | An @Provide decorated state variable becomes available to all descendent components of the providing component automatically. The variable is said to be “provided” to other components. This means that you do not need to pass a variable from component to component multiple times. | A descendent component gains access to the provided state variable by decorating a variable with @Consume. This establishes a two-way data synchronization between the provided and the consumed variable. This synchronization works in the same manner as a combination of @State and @Link does. The only difference is that the former allows transfer across multiple levels of the UI parent-child hierarchy. | @Provide and @Consume can be bound using the same variable name or variable alias. Whenever possible, use the same variable types to prevent implicit type conversion and consequently application behavior exceptions. | . // Binding through the same variable name @Provide a: number = 0; @Consume a: number; // Binding through the same variable alias @Provide('a') b: number = 0; @Consume('a') c: number; . When @Provide and @Consume are bound through the same variable name or variable alias, the variables decorated by @Provide and @Consume are in a one-to-many relationship. A custom component, including its child components, should not contain multiple @Provide decorated variables under the same name or alias. Otherwise, a runtime error will occur. ",
    "url": "/application-development/state-management-decorators/provide-consume-decorator.html#features",
    
    "relUrl": "/application-development/state-management-decorators/provide-consume-decorator.html#features"
  },"133": {
    "doc": "Provide and Consume Decorators",
    "title": "Usage Scenarios",
    "content": "The following example shows the two-way synchronization between @Provide and @Consume decorated variables. When the buttons in the CompA and CompD components are clicked, the changes to reviewVotes are synchronized to the CompA and CompD components. @Component struct CompD { // The @Consume decorated variable is bound to the @Provide decorated variable in its ancestor component CompA under the same attribute name. @Consume reviewVotes: number; build() { Column() { Text(`reviewVotes(${this.reviewVotes})`) Button(`reviewVotes(${this.reviewVotes}), give +1`) .onClick(() =&gt; this.reviewVotes += 1) } .width('50%') } } @Component struct CompC { build() { Row({ space: 5 }) { CompD() CompD() } } } @Component struct CompB { build() { CompC() } } @Entry @Component struct CompA { // @Provide decorated variable reviewVotes is provided by the entry component CompA. @Provide reviewVotes: number = 0; build() { Column() { Button(`reviewVotes(${this.reviewVotes}), give +1`) .onClick(() =&gt; this.reviewVotes += 1) CompB() } } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/provide-consume-decorator.html#usage-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/provide-consume-decorator.html#usage-scenarios"
  },"134": {
    "doc": "Provide and Consume Decorators",
    "title": "Provide and Consume Decorators",
    "content": " ",
    "url": "/application-development/state-management-decorators/provide-consume-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/provide-consume-decorator.html"
  },"135": {
    "doc": "qemu",
    "title": "qemu",
    "content": "qemu . ",
    "url": "/device-development/supported-device/virtual-machine/qemu.html",
    
    "relUrl": "/device-development/supported-device/virtual-machine/qemu.html"
  },"136": {
    "doc": "Building Oniro",
    "title": "Building Oniro",
    "content": "Before beginning, ensure that git-lfs and repo are installed. It is recommended to have at least 100GB of free disk space available for the full build. ",
    "url": "/device-development/quick-build-with-oniro.html#building-oniro",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#building-oniro"
  },"137": {
    "doc": "Building Oniro",
    "title": "Obtaining the Source Code",
    "content": "To download the source code, execute the following commands in your terminal: . repo init -u https://github.com/eclipse-oniro4openharmony/manifest.git -b OpenHarmony-4.1-Release -m oniro.xml --no-repo-verify repo sync -c repo forall -c 'git lfs pull' . ",
    "url": "/device-development/quick-build-with-oniro.html#obtaining-the-source-code",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#obtaining-the-source-code"
  },"138": {
    "doc": "Building Oniro",
    "title": "Fetching Prebuilt Tools",
    "content": "Once you have the source code run the following script to fetch the prebuilt tools: ./build/prebuilts_download.sh . ",
    "url": "/device-development/quick-build-with-oniro.html#fetching-prebuilt-tools",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#fetching-prebuilt-tools"
  },"139": {
    "doc": "Building Oniro",
    "title": "Setting Up the Build Environment",
    "content": "For building the project, using an isolated Docker container is recommended for a clean and controlled build environment. Run the following command to start the Docker container: . docker run -it -v $(pwd):/home/openharmony swr.cn-south-1.myhuaweicloud.com/openharmony-docker/docker_oh_standard:3.2 . ",
    "url": "/device-development/quick-build-with-oniro.html#setting-up-the-build-environment",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#setting-up-the-build-environment"
  },"140": {
    "doc": "Building Oniro",
    "title": "Configuring and Starting the Build",
    "content": "Inside the Docker instance, set the target device for the build (e.g. rk3568) and use ccache to speed up subsequent builds: ./build.sh --product-name rk3568 --ccache . ",
    "url": "/device-development/quick-build-with-oniro.html#configuring-and-starting-the-build",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#configuring-and-starting-the-build"
  },"141": {
    "doc": "Building Oniro",
    "title": "Flashing",
    "content": "The flashing procedure is highly hardware specific and can be found in the Developer Boards section for each individual device. ",
    "url": "/device-development/quick-build-with-oniro.html#flashing",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#flashing"
  },"142": {
    "doc": "Building Oniro",
    "title": "Additional Tips and Troubleshooting",
    "content": "No HDC available in the system . If the hdc tool is not available on your host system, build it using the ohos-sdk: ./build.sh --product-name ohos-sdk --ccache . Find the hdc tool in out/sdk/ohos-sdk/linux/toolchains. To verify the connection with the device, run: . $ hdc list targets 150100424a544434520325874bb44900 . For sending commands to the device: . hdc shell . To read hilog output: . hdc hilog . Speeding Up Build Times . You can significantly reduce build times for subsequent builds by mounting directories for prebuilts and ccache when initiating the Docker container. This approach ensures that once the prebuilts are downloaded, they don’t need to be fetched again, and the compilation cache is maintained across builds. To apply this optimization, use the following command to start your Docker container: . docker run -it -v $(pwd):/home/openharmony/workdir -v ~/openharmony_prebuilts:/home/openharmony/openharmony_prebuilts -v ~/.ccache:/root/.ccache swr.cn-south-1.myhuaweicloud.com/openharmony-docker/docker_oh_standard:3.2 . After starting the container with the above command, navigate to the workdir directory before initiating the build process: . cd workdir . ",
    "url": "/device-development/quick-build-with-oniro.html#additional-tips-and-troubleshooting",
    
    "relUrl": "/device-development/quick-build-with-oniro.html#additional-tips-and-troubleshooting"
  },"143": {
    "doc": "Building Oniro",
    "title": "Building Oniro",
    "content": "Text from here . ",
    "url": "/device-development/quick-build-with-oniro.html",
    
    "relUrl": "/device-development/quick-build-with-oniro.html"
  },"144": {
    "doc": "Refactoring",
    "title": "Rename Symbol",
    "content": "This refactoring tool allows you to consistently rename symbols (variables, functions, methods, classes, etc.) throughout your codebase. This is particularly useful when you want to rename a symbol without manually updating each occurrence in different files. Right click on a symbol you want to rename and choose Rename Symbol or press F2. Write the new name and press Enter, or press Shift+Enter to preview your changes in a separate pane before applying them. ",
    "url": "/device-development/oniro-ide/refacting.html#rename-symbol",
    
    "relUrl": "/device-development/oniro-ide/refacting.html#rename-symbol"
  },"145": {
    "doc": "Refactoring",
    "title": "Extract Method",
    "content": "The “Extract Method” refactoring action in Oniro IDE allows you to take a block of code within a function and create a new method for that block. This can improve code readability, maintainability, and reusability. Here’s an example in javascript to illustrate how to use the “Extract Method” feature: . function calculateTotal(price, quantity) { let taxRate = 0.1; let subtotal = price * quantity; let tax = subtotal * taxRate; let total = subtotal + tax; console.log(\"Total: $\" + total.toFixed(2)); } . If you want to extract tax calculation part into a separate method you could use the Extract Method. Simply select the code fragment, click on the light bulb and choose the scope for the new function. During the extract refactoring, you will be prompted to provide a meaningful name. The final code should look like this: . function calculateTotal(price, quantity) { let taxRate = 0.1; let subtotal = price * quantity; let tax = calcTax(subtotal); let total = subtotal + tax; console.log(\"Total: $\" + total.toFixed(2)); } function calcTax(subtotal) { let taxRate = 0.1; return subtotal * taxRate; } . ",
    "url": "/device-development/oniro-ide/refacting.html#extract-method",
    
    "relUrl": "/device-development/oniro-ide/refacting.html#extract-method"
  },"146": {
    "doc": "Refactoring",
    "title": "Extract Variable",
    "content": "allows you to take an expression in your code and create a new variable to store the result of that expression. Let’s revisit our initial example: . function calculateTotal(price, quantity) { let taxRate = 0.1; let subtotal = price * quantity; let total = subtotal + subtotal * taxRate; console.log(\"Total: $\" + total.toFixed(2)); } . This time the total is calculated right away in long formula that includes the tax calculation. To make it more readable we want to extract the tax calculation in a separate variable. Hence, we select the subtotal * taxRate code fragment, click on the light bulb, choose Extract to constant in enclosing scope and give the constant a name e.g. tax. The outcome should be as follows: . function calculateTotal(price, quantity) { let taxRate = 0.1; let subtotal = price * quantity; const tax = subtotal * taxRate; let total = subtotal + tax; console.log(\"Total: $\" + total.toFixed(2)); } . ",
    "url": "/device-development/oniro-ide/refacting.html#extract-variable",
    
    "relUrl": "/device-development/oniro-ide/refacting.html#extract-variable"
  },"147": {
    "doc": "Refactoring",
    "title": "Refactoring",
    "content": "Code Refactoring is an essential part of the software engineering life cycle. In this topic we will explain a few refactoring actions that are embedded into the IDE namely, Rename Symbol, Extract Method, and Extract Variable. ",
    "url": "/device-development/oniro-ide/refacting.html",
    
    "relUrl": "/device-development/oniro-ide/refacting.html"
  },"148": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Raspberry Pi 4 Model B Development Kit",
    "content": "Text from here . ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#raspberry-pi-4-model-b-development-kit",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#raspberry-pi-4-model-b-development-kit"
  },"149": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Introduction",
    "content": "The Raspberry Pi 4B is powered by the Broadcom BCM2711, a quad-core Cortex-A72 (ARM v8) 64-bit SoC clocked at 1.8GHz. It offers significant performance improvements over previous models, making it an ideal choice for projects requiring higher processing power. The board also supports a variety of peripherals including high-speed USB 3.0, dual HDMI outputs, and Gigabit Ethernet. The onboard wireless capabilities (Wi-Fi and Bluetooth) and the Raspberry Pi’s standard 40-pin GPIO header ensure a wide range of expansion possibilities. It’s an excellent platform for IoT, media centers, and general-purpose computing projects. The Oniro Project supports the Raspberry Pi 4B, and the following features have been verified to be working: . | GPU graphical acceleration | USB camera support | HDMI output | Touch input | Mouse input | . Oniro on Raspberry Pi 4b and waveshare 7inch touch screen . ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#introduction",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#introduction"
  },"150": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Specification",
    "content": "Development Board Specification . | Category | Specification | . | SOC Model | Broadcom BCM2711 | . | CPU Architecture | Quad-core Cortex-A72 (ARM v8) 64-bit SoC @ 1.8GHz | . | GPU | OpenGL ES 3.1, Vulkan 1.0 | . | Wireless | 2.4 GHz and 5.0 GHz IEEE 802.11ac wireless, Bluetooth 5.0, BLE | . | Ethernet | Gigabit Ethernet | . | RAM | 1GB, 2GB, 4GB, or 8GB LPDDR4-3200 SDRAM (depending on model) | . | Video Decoding | H.265 (4kp60 decode), H.264 (1080p60 decode, 1080p30 encode) | . | Power Input | 5V DC via USB-C connector (minimum 3A) or GPIO header | . | Operating Temperature | 0 – 50 degrees C ambient | . | Storage | Micro-SD card slot for OS and data storage | . | Operating Systems | Supports various Linux distributions, including Oniro | . Expansion Board Specification . | Category | Specification | . | HDMI | 2x micro-HDMI (supports 4K at 60fps output) | . | MIPI | 2-lane MIPI DSI display port, 2-lane MIPI CSI camera port | . | USB | 2x USB 3.0 ports, 2x USB 2.0 ports | . | GPIO | 40-pin GPIO header (fully backwards compatible) | . | Audio/Video | 4-pole stereo audio and composite video port | . | PoE | Power over Ethernet (requires separate PoE HAT) | . ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#specification",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#specification"
  },"151": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Building",
    "content": "After completing the steps in the quick build documentation to set up your build environment, proceed with the following steps to compile and build the system image for the Raspberry Pi 4B. Step 1: Prepare the Build Environment . Run the following script to apply system patches: . chmod 777 device/board/rpi/system_patch/system_patch.sh ./device/board/rpi/system_patch/system_patch.sh . Step 2: Compile the System Image . Execute the following command to build the system image: ./build.sh --product-name rpi4 --ccache . Step 3: Package the System Image . Once the compilation is complete, package the image using this command: ./build.sh --product-name rpi4 --ccache --build-target rpi_image . The compiled files will be archived in the out/rpi4/ directory, and the final image will be located at: . out/rpi4/packages/phone/images/ . ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#building",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#building"
  },"152": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Flashing",
    "content": "To flash the image, follow these steps in a Linux environment: . Step 1: Insert the SD Card . Insert your SD card (at least 16GB) into the card reader and connect it to your computer. Step 2: Identify the Device . Run the following command to list all connected devices: . lsblk . Locate your SD card by identifying its size in the list. The device name will be something like /dev/sdX, where X is a letter such as b, c, etc. For example, it could be /dev/sdc. Step 3: Unmount the Device . If the device has any mounted partitions, you must unmount them before flashing the image. For example, if your device is /dev/sdc, run the following command to unmount all partitions: . sudo umount /dev/sdc* . Step 4: Flash the Image . Now, use the dd command to write the image file to the SD card. Replace /dev/sdX with the appropriate device name (e.g., /dev/sdc), and run the following command: . sudo dd if=out/rpi4/packages/phone/images/rpi_image.img of=/dev/sdX bs=4M conv=fsync status=progress . This will begin the flashing process. The status=progress option will display the progress of the flashing process. Step 5: Eject the SD Card . Once the flashing is complete, safely eject the SD card using the following command: . sudo eject /dev/sdX . You can now insert the SD card into your Raspberry Pi 4B for use. ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#flashing",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#flashing"
  },"153": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Debugging",
    "content": "1. Connecting via Serial . To debug via serial, use the following pin configuration: . Connect the pins as shown in the diagram (Pins 6, 8, and 10). Then, use the following Minicom command to establish the serial connection: . sudo minicom --device /dev/ttyUSB0 --baudrate 115200 . Make sure to replace /dev/ttyUSB0 with the appropriate serial port for your setup. Tip: After establishing the serial connection, you will have access to the device’s shell. If the device is connected to a network, you can retrieve the IP address by running the ifconfig command. This will be useful for the next section on “Using the HDC Tool” to connect to the device over the network. 2. Using the HDC Tool . The HDC tool can be used for various debugging tasks. To connect, first connect the device via Ethernet to obtain the IP address, and then run the following command: . hdc tconn &lt;device-ip&gt;:5555 . You should see Connect OK if the connection is successful. Here are some useful HDC commands: . | hdc shell: Opens a shell to the device. | hdc file send {local_path} {device_path}: Sends a file from your local system to the device. | hdc file recv {device_path} {local_path}: Receives a file from the device. | hdc install &lt;filename.hap&gt;: Installs a .hap package on the device. | . ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html#debugging",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html#debugging"
  },"154": {
    "doc": "Raspberry Pi 4 Model B",
    "title": "Raspberry Pi 4 Model B",
    "content": " ",
    "url": "/device-development/supported-device/boards/respberry-pi-4model-b.html",
    
    "relUrl": "/device-development/supported-device/boards/respberry-pi-4model-b.html"
  },"155": {
    "doc": "Running the Application on a Real Device",
    "title": "Running the Application on a Real Device",
    "content": "Install HDC . | Find the pipeline whose name is ohos-sdk-full or ohos-sdk-public, click Download Link, and select Full Package. | . Note: You can skip this part if you followed the procedure from Environment Setup and Configuration tutorial. Use conditional filtering, such as selecting the project as openharmony, selecting the target branch OpenHarmony-4.1-Release, selecting a date from the previous month, or manually choosing a range. In the daily build or rolling build, find ohos-sdk-full_4.1-Release, and click on the download link to choose and download the full package, which includes Full-SDK for Windows and Linux. (If daily build SDK is not compatible with your version of DevEco Studio, try to use rolling build SDK instead) . | Under toolchain folder, find hdc.exe and libusb_shared.ddl. | . | Create a folder called hdc_bin, you can create it wherever you like and put hdc.exe and libusb_shared into that folder. | . | Add Environment Variable . | Open Settings on Windows system, type environment to search Edit the system environment variables and click it. | . | . | Make sure the System Properties window is under Advanced tab, click Environment Variables... | . | Double click Path in System variables area. Click New on new pop-up window and paste your hdc_bin folder path. After that, click OK for all windows. | . | Check whether the HDC is running properly You can open your Command prompt and type hdc to check. | . Use real machine to run application with USB . | Connect the development board(Here I used HiHope HH-SCDAYU200 Development Kit) running the OpenHarmony standard system to the computer and you can find the running device on the top part of the IDE. | . | Generate signature. | Click Project Structure... icon on the top-right corner of the IDE, Choose Project &gt; Signing Configs and select Automatically generate signature. | Click Apply and wait until the automatic signing is complete. | . | . | You can find signed signature in configuration folder and open build-profile.json5 file. | . | Click Run 'entry' triangle button. | . | You can observe the application running on the board. | . You learned about DevEco Studio and built your first Eclipse Oniro Application, congratulations! . ",
    "url": "/application-development/create-first-eclipse-oniro-app/run-real-device.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/run-real-device.html"
  },"156": {
    "doc": "State Decorator",
    "title": "@State Decorator",
    "content": "Variables decorated with @State, also known as state variable, are used in our development to declare internal component states. When a property is decorated with @State, it becomes a reactive state of the component. This means that whenever the property’s value changes, the component will automatically re-render to reflect the updated state. ",
    "url": "/application-development/state-management-decorators/state-decorator.html#state-decorator",
    
    "relUrl": "/application-development/state-management-decorators/state-decorator.html#state-decorator"
  },"157": {
    "doc": "State Decorator",
    "title": "Features",
    "content": ". | A one-way synchronization relationship can be set up from an @State decorated variable to an @Prop decorated variable in a child component, and a two-way synchronization relationship to an @Link or @ObjectLink decorated variable. | The lifecycle of the @State decorated variable is the same as that of its owning custom component. | . ",
    "url": "/application-development/state-management-decorators/state-decorator.html#features",
    
    "relUrl": "/application-development/state-management-decorators/state-decorator.html#features"
  },"158": {
    "doc": "State Decorator",
    "title": "Use Scenarios",
    "content": "Decorating Simple Type Variables . Below is a simple counter component to demonstrate how the @State decorator works. @Entry @Component struct MyComponent { @State count: number = 0; // State variable build() { Button(`click times: ${this.count}`) .width(200) .height(80) .fontSize(20) .margin(60) .onClick(() =&gt; { this.count += 1; // Increment count on button click }) } } . In the code above, we define a component named MyComponent, which contains a state variable called count. We declare the count property using the @State decorator, making it a reactive state. When the user clicks the button, the value of count is incremented by 1, and the component automatically re-renders to display the latest count. Decorating the Class Object Type Variables . | In this example, @State is used to decorate the variables count and title in the custom component MyComponent. The type of title is Model, a custom class. If the value of count or title changes, the framework searches for all MyComponent instances that depend on these variables and triggers re-rendering of them. | The EntryComponent has multiple MyComponent instances. The internal state change of the first MyComponent instance does not affect the second MyComponent instance. | . class Model { public value: string; constructor(value: string) { this.value = value; } } @Entry @Component struct EntryComponent { build() { Column() { // The parameters specified here will overwrite the default values defined locally during initial render. Not all parameters need to be initialized from the parent component. MyComponent({ count: 1, increaseBy: 2 }) .width(300) MyComponent({ title: new Model('Hello World 2'), count: 7 }) } } } @Component struct MyComponent { @State title: Model = new Model('Hello World'); @State count: number = 0; private increaseBy: number = 1; build() { Column() { Text(`${this.title.value}`) .margin(10) Button(`Click to change title`) .onClick(() =&gt; { // The update of the @State decorated variable triggers the update of the &lt;Text&gt; component. this.title.value = this.title.value === 'Hello ArkUI' ? 'Hello World' : 'Hello ArkUI'; }) .width(300) .margin(10) Button(`Click to increase count = ${this.count}`) .onClick(() =&gt; { // The update of the @State decorated variable triggers the update of the &lt;Button&gt; component. this.count += this.increaseBy; }) .width(300) .margin(10) } } } . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/state-decorator.html#use-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/state-decorator.html#use-scenarios"
  },"159": {
    "doc": "State Decorator",
    "title": "State Decorator",
    "content": " ",
    "url": "/application-development/state-management-decorators/state-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/state-decorator.html"
  },"160": {
    "doc": "System Requirement",
    "title": "System Requirement",
    "content": "For this tutorial, we use Windows system as example, it is recommended to meet the following requirements: . Operating system: Windows 10 64-bit . Memory: at least 8 GB . Hard disk: at least 100 GB . Resolution: at least 1280 x 800 pixels . ",
    "url": "/application-development/environment-setup-config/system-requirement.html",
    
    "relUrl": "/application-development/environment-setup-config/system-requirement.html"
  },"161": {
    "doc": "UIAbility and Component",
    "title": "UIAbility and Component",
    "content": "to do . ",
    "url": "/application-development/basic-concepts/uiability-and-component.html",
    
    "relUrl": "/application-development/basic-concepts/uiability-and-component.html"
  },"162": {
    "doc": "Usage of Previewer",
    "title": "Usage of Previewer",
    "content": "To preview the UI display effect of a file in real-time using DevEco Studio’s Previewer, click on the Previewer tab located on the right side of the DevEco Studio interface. During UI code development, if you add or remove UI components, simply save your changes by pressing Ctrl+S or click Reload. The Previewer will then immediately refresh to reflect the updated UI. Note: For .ets file, Previewer only works with components which decorated with @Entry or @Preview decorator. DevEco Studio’s Previewer offers several essential features to enhance the UI development experience: . | Screen Rotation: You can switch between portrait and landscape orientations by clicking the Orientation button within the Previewer. | . | Device Switching: The Previewer allows you to switch between different device profiles to see how your application appears on various devices. | . | Multi-Device Preview: By enabling the multi-device preview feature, you can simultaneously view your application’s UI across multiple devices. | . | Code Inspection: ​DevEco Studio’s Inspector feature enables bidirectional interaction between the code editor, UI preview, and component tree. | . These features collectively provide a comprehensive environment to visualize and fine-tune your application’s user interface across different devices and orientations. ",
    "url": "/application-development/create-first-eclipse-oniro-app/use-previewer.html",
    
    "relUrl": "/application-development/create-first-eclipse-oniro-app/use-previewer.html"
  },"163": {
    "doc": "User Interface",
    "title": "User Interface",
    "content": "At its heart, Oniro IDE is a code editor. Like many other code editors, Oniro IDE adopts a common user interface and layout of an explorer on the left, showing all of the files and folders you can access, and an editor on the right, showing the content of the files you have opened. ",
    "url": "/device-development/oniro-ide/user-interface.html",
    
    "relUrl": "/device-development/oniro-ide/user-interface.html"
  },"164": {
    "doc": "User Interface",
    "title": "Basic Layout",
    "content": "The basic layout consists of 8 main areas: . | Menu Bar: that contains the main menus such as File, Edit, View, Run..etc. | Tool Bar: for going home, and toggling the explorer and debugging side bars. | Layout Bar: for changing the layout and positioning of the tool bar. | Editor Groups: with all the different files you are editing. You open as many files as you want and stack them horizontally and vertically. | Primary Side Bar: usually hosts the Explorer view to assist you in navigating and working on your project. | Panel: space for views below the editor area. It typically has the integrated terminal, output and errors. You can also stack multiple views in the panel or have it as a pop out in a separate window. | Status Bar: shows the status of the file you are currently editing such as the language used in the file. | Secondary Side Bar: hosts an extra view on the right hand side such as a Debugging side bar. | . ",
    "url": "/device-development/oniro-ide/user-interface.html#basic-layout",
    
    "relUrl": "/device-development/oniro-ide/user-interface.html#basic-layout"
  },"165": {
    "doc": "User Interface",
    "title": "Explorer",
    "content": "The explorer is used to browse, open, and manage all the files and folders in your project. You can create a new file or folder at any time in your project. You can do many things to files and folders in the explorer: . | Create, delete, rename files and folders by right click. | Move files and folders by drag and drop. | Duplicate, copy and paste files into a folder. | . Note: You could run commands in a folder by right clicking on the folder itself or a file in the folder and choosing Open in Terminal from the pop out menu. Open Editors . On the top of the Explorer side view you can find a pane called Open Editors that shows all the files that you currently have open. This allows for quick navigation between the opened editor tabs. ",
    "url": "/device-development/oniro-ide/user-interface.html#explorer",
    
    "relUrl": "/device-development/oniro-ide/user-interface.html#explorer"
  },"166": {
    "doc": "User Interface",
    "title": "Views",
    "content": "The Explorer is one of multiple other views available in Oniro IDE. By navigating to View from the menu bar, you can see the multiple views that can be opened, such as: . | Search Provides global search and replace across your open folder. | Debug for debugging tools displaying the Call Stack, Variables, Breakpoints throughout the code, and a Watch monitoring select variables. | Outline shows a symbol tree of the currently active editor showing the variables in your code. | . ",
    "url": "/device-development/oniro-ide/user-interface.html#views",
    
    "relUrl": "/device-development/oniro-ide/user-interface.html#views"
  },"167": {
    "doc": "Watch Decorator",
    "title": "@Watch Decorator",
    "content": "@Watch is used to listen for state variables. If your application needs watch for value changes of a state variable, you can decorate the variable with @Watch. NOTE . Since API version 9, this decorator is supported in ArkTS widgets. ",
    "url": "/application-development/state-management-decorators/watch-decorator.html#watch-decorator",
    
    "relUrl": "/application-development/state-management-decorators/watch-decorator.html#watch-decorator"
  },"168": {
    "doc": "Watch Decorator",
    "title": "Overview",
    "content": "An application can request to be notified whenever the value of the @Watch decorated variable changes. The @Watch callback is called when the value change has occurred. @Watch uses strict equality (===) to determine whether a value is updated in the ArkUI framework. If false is returned, the @Watch callback is triggered. ",
    "url": "/application-development/state-management-decorators/watch-decorator.html#overview",
    
    "relUrl": "/application-development/state-management-decorators/watch-decorator.html#overview"
  },"169": {
    "doc": "Watch Decorator",
    "title": "Restrictions",
    "content": ". | Pay attention to the risk of infinite loops. Loops can be caused by the @Watch callback directly or indirectly mutating the same variable. To avoid loops, avoid mutating the @Watch decorated state variable inside the callback handler. | Pay attention to performance. The attribute value update function delays component re-render (see the preceding behavior description). The callback should only perform quick computations. | Calling async await from an @Watch function is not recommended, because asynchronous behavior may cause performance issues of re-rendering. | . ",
    "url": "/application-development/state-management-decorators/watch-decorator.html#restrictions",
    
    "relUrl": "/application-development/state-management-decorators/watch-decorator.html#restrictions"
  },"170": {
    "doc": "Watch Decorator",
    "title": "Application Scenarios",
    "content": "@Watch and Custom Component Update . This example is used to clarify the processing steps of custom component updates and @Watch. count is decorated by @State in CountModifier and @Prop in TotalView. @Component struct TotalView { @Prop @Watch('onCountUpdated') count: number = 0; @State total: number = 0; // @Watch callback onCountUpdated(propName: string): void { this.total += this.count; } build() { Text(`Total: ${this.total}`) } } @Entry @Component struct CountModifier { @State count: number = 0; build() { Column() { Button('add to basket') .onClick(() =&gt; { this.count++ }) TotalView({ count: this.count }) } } } . Processing steps: . | The click event Button.onClick of the CountModifier custom component increases the value of count. | In response to the change of the @State decorated variable count, @Prop in the child component TotalView is updated, and its @Watch(‘onCountUpdated’) callback is triggered, which updates the total variable in TotalView. | The Text component in the child component TotalView is re-rendered. | . Additional Information . For more detailed information, click the link here . ",
    "url": "/application-development/state-management-decorators/watch-decorator.html#application-scenarios",
    
    "relUrl": "/application-development/state-management-decorators/watch-decorator.html#application-scenarios"
  },"171": {
    "doc": "Watch Decorator",
    "title": "Watch Decorator",
    "content": " ",
    "url": "/application-development/state-management-decorators/watch-decorator.html",
    
    "relUrl": "/application-development/state-management-decorators/watch-decorator.html"
  }
}
